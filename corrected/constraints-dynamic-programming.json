{
  "topic": "dynamic-programming",
  "problems": {
    "01-matrix": {
      "questionId": "542",
      "title": "01 Matrix",
      "difficulty": "Medium",
      "constraints": [
        "m == mat.length",
        "n == mat[i].length",
        "1 <= m, n <= 104",
        "1 <= m * n <= 104",
        "mat[i][j] is either 0 or 1.",
        "There is at least one 0 in mat."
      ],
      "description": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two cells sharing a common edge is 1.\nExample 1:\nExample 2:\nConstraints:\nNote: This question is the same as 1765: https://leetcode.com/problems/map-of-highest-peak/"
    },
    "all-possible-full-binary-trees": {
      "questionId": "894",
      "title": "All Possible Full Binary Trees",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 20"
      ],
      "description": "Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.\nEach element of the answer is the root node of one possible tree. You may return the final list of trees in any order.\nA full binary tree is a binary tree where each node has exactly 0 or 2 children.\nExample 1:\nExample 2:\nConstraints:"
    },
    "arithmetic-slices": {
      "questionId": "413",
      "title": "Arithmetic Slices",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 5000",
        "-1000 <= nums[i] <= 1000"
      ],
      "description": "An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nGiven an integer array nums, return the number of arithmetic subarrays of nums.\nA subarray is a contiguous subsequence of the array.\nExample 1:\nExample 2:\nConstraints:"
    },
    "beautiful-arrangement": {
      "questionId": "526",
      "title": "Beautiful Arrangement",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 15"
      ],
      "description": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:\nGiven an integer n, return the number of the beautiful arrangements that you can construct.\nExample 1:\nExample 2:\nConstraints:"
    },
    "best-sightseeing-pair": {
      "questionId": "1014",
      "title": "Best Sightseeing Pair",
      "difficulty": "Medium",
      "constraints": [
        "2 <= values.length <= 5 * 104",
        "1 <= values[i] <= 1000"
      ],
      "description": "You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.\nThe score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.\nReturn the maximum score of a pair of sightseeing spots.\nExample 1:\nExample 2:\nConstraints:"
    },
    "best-time-to-buy-and-sell-stock": {
      "questionId": "121",
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "Easy",
      "constraints": [
        "1 <= prices.length <= 105",
        "0 <= prices[i] <= 104"
      ],
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nExample 2:\nConstraints:"
    },
    "best-time-to-buy-and-sell-stock-ii": {
      "questionId": "122",
      "title": "Best Time to Buy and Sell Stock II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= prices.length <= 3 * 104",
        "0 <= prices[i] <= 104"
      ],
      "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "best-time-to-buy-and-sell-stock-with-cooldown": {
      "questionId": "309",
      "title": "Best Time to Buy and Sell Stock with Cooldown",
      "difficulty": "Medium",
      "constraints": [
        "1 <= prices.length <= 5000",
        "0 <= prices[i] <= 1000"
      ],
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nExample 2:\nConstraints:"
    },
    "best-time-to-buy-and-sell-stock-with-transaction-fee": {
      "questionId": "714",
      "title": "Best Time to Buy and Sell Stock with Transaction Fee",
      "difficulty": "Medium",
      "constraints": [
        "1 <= prices.length <= 5 * 104",
        "1 <= prices[i] < 5 * 104",
        "0 <= fee < 5 * 104"
      ],
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\nNote:\nExample 1:\nExample 2:\nConstraints:"
    },
    "binary-trees-with-factors": {
      "questionId": "823",
      "title": "Binary Trees With Factors",
      "difficulty": "Medium",
      "constraints": [
        "1 <= arr.length <= 1000",
        "2 <= arr[i] <= 109",
        "All the values of arr are unique."
      ],
      "description": "Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\nReturn the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.\nExample 1:\nExample 2:\nConstraints:"
    },
    "champagne-tower": {
      "questionId": "799",
      "title": "Champagne Tower",
      "difficulty": "Medium",
      "constraints": [
        "0 <=\u00a0poured <= 109",
        "0 <= query_glass <= query_row\u00a0< 100"
      ],
      "description": "We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.\u00a0 Each glass holds one cup\u00a0of champagne.\nThen, some champagne is poured into the first glass at the top.\u00a0 When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.\u00a0 When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.\u00a0 (A glass at the bottom row has its excess champagne fall on the floor.)\nFor example, after one cup of champagne is poured, the top most glass is full.\u00a0 After two cups of champagne are poured, the two glasses on the second row are half full.\u00a0 After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.\u00a0 After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\nNow after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "cheapest-flights-within-k-stops": {
      "questionId": "787",
      "title": "Cheapest Flights Within K Stops",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 100",
        "0 <= flights.length <= (n * (n - 1) / 2)",
        "flights[i].length == 3",
        "0 <= fromi, toi < n",
        "fromi != toi",
        "1 <= pricei <= 104",
        "There will not be any multiple flights between two cities.",
        "0 <= src, dst, k < n",
        "src != dst"
      ],
      "description": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "climbing-stairs": {
      "questionId": "70",
      "title": "Climbing Stairs",
      "difficulty": "Easy",
      "constraints": [
        "1 <= n <= 45"
      ],
      "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nExample 2:\nConstraints:"
    },
    "coin-change": {
      "questionId": "322",
      "title": "Coin Change",
      "difficulty": "Medium",
      "constraints": [
        "1 <= coins.length <= 12",
        "1 <= coins[i] <= 231 - 1",
        "0 <= amount <= 104"
      ],
      "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "coin-change-ii": {
      "questionId": "518",
      "title": "Coin Change II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= coins.length <= 300",
        "1 <= coins[i] <= 5000",
        "All the values of coins are unique.",
        "0 <= amount <= 5000"
      ],
      "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "combination-sum-iv": {
      "questionId": "377",
      "title": "Combination Sum IV",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 200",
        "1 <= nums[i] <= 1000",
        "All the elements of nums are unique.",
        "1 <= target <= 1000"
      ],
      "description": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to\u00a0target.\nThe test cases are generated so that the answer can fit in a 32-bit integer.\nExample 1:\nExample 2:\nConstraints:\nFollow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?"
    },
    "decode-ways": {
      "questionId": "91",
      "title": "Decode Ways",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 100",
        "s contains only digits and may contain leading zero(s)."
      ],
      "description": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\nNote: there may be strings that are impossible to decode.\n\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "delete-and-earn": {
      "questionId": "740",
      "title": "Delete and Earn",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 2 * 104",
        "1 <= nums[i] <= 104"
      ],
      "description": "You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:\nReturn the maximum number of points you can earn by applying the above operation some number of times.\nExample 1:\nExample 2:\nConstraints:"
    },
    "delete-operation-for-two-strings": {
      "questionId": "583",
      "title": "Delete Operation for Two Strings",
      "difficulty": "Medium",
      "constraints": [
        "1 <= word1.length, word2.length <= 500",
        "word1 and word2 consist of only lowercase English letters."
      ],
      "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.\nExample 1:\nExample 2:\nConstraints:"
    },
    "domino-and-tromino-tiling": {
      "questionId": "790",
      "title": "Domino and Tromino Tiling",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 1000"
      ],
      "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\nExample 1:\nExample 2:\nConstraints:"
    },
    "edit-distance": {
      "questionId": "72",
      "title": "Edit Distance",
      "difficulty": "Medium",
      "constraints": [
        "0 <= word1.length, word2.length <= 500",
        "word1 and word2 consist of lowercase English letters."
      ],
      "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nExample 1:\nExample 2:\nConstraints:"
    },
    "flip-string-to-monotone-increasing": {
      "questionId": "926",
      "title": "Flip String to Monotone Increasing",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 105",
        "s[i] is either '0' or '1'."
      ],
      "description": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "house-robber": {
      "questionId": "198",
      "title": "House Robber",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 100",
        "0 <= nums[i] <= 400"
      ],
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nExample 2:\nConstraints:"
    },
    "house-robber-ii": {
      "questionId": "213",
      "title": "House Robber II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 100",
        "0 <= nums[i] <= 1000"
      ],
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and\u00a0it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "house-robber-iii": {
      "questionId": "337",
      "title": "House Robber III",
      "difficulty": "Medium",
      "constraints": [
        "The number of nodes in the tree is in the range [1, 104].",
        "0 <= Node.val <= 104"
      ],
      "description": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.\nBesides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.\nGiven the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\nExample 1:\nExample 2:\nConstraints:"
    },
    "integer-replacement": {
      "questionId": "397",
      "title": "Integer Replacement",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 231 - 1"
      ],
      "description": "Given a positive integer n,\u00a0you can apply one of the following\u00a0operations:\nReturn the minimum number of operations needed for n to become 1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "interleaving-string": {
      "questionId": "97",
      "title": "Interleaving String",
      "difficulty": "Medium",
      "constraints": [
        "0 <= s1.length, s2.length <= 100",
        "0 <= s3.length <= 200",
        "s1, s2, and s3 consist of lowercase English letters."
      ],
      "description": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\nNote: a + b is the concatenation of strings a and b.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve it using only O(s2.length) additional memory space?"
    },
    "jump-game": {
      "questionId": "55",
      "title": "Jump Game",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 104",
        "0 <= nums[i] <= 105"
      ],
      "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "jump-game-ii": {
      "questionId": "45",
      "title": "Jump Game II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 104",
        "0 <= nums[i] <= 1000",
        "It's guaranteed that you can reach nums[n - 1]."
      ],
      "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\nExample 1:\nExample 2:\nConstraints:"
    },
    "knight-dialer": {
      "questionId": "935",
      "title": "Knight Dialer",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 5000"
      ],
      "description": "The chess knight has a unique movement,\u00a0it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagram:\nA chess knight can move as indicated in the chess diagram below:\nWe have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell\u00a0(i.e. blue cell).\nGiven an integer n, return how many distinct phone numbers of length n we can dial.\nYou are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\nAs the answer may be very large, return the answer modulo 109 + 7.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "knight-probability-in-chessboard": {
      "questionId": "688",
      "title": "Knight Probability in Chessboard",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 25",
        "0 <= k <= 100",
        "0 <= row, column <= n - 1"
      ],
      "description": "On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\nThe knight continues moving until it has made exactly k moves or has moved off the chessboard.\nReturn the probability that the knight remains on the board after it has stopped moving.\nExample 1:\nExample 2:\nConstraints:"
    },
    "largest-plus-sign": {
      "questionId": "764",
      "title": "Largest Plus Sign",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 500",
        "1 <= mines.length <= 5000",
        "0 <= xi, yi < n",
        "All the pairs (xi, yi) are unique."
      ],
      "description": "You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.\nReturn the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.\nAn axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.\nExample 1:\nExample 2:\nConstraints:"
    },
    "largest-sum-of-averages": {
      "questionId": "813",
      "title": "Largest Sum of Averages",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 100",
        "1 <= nums[i] <= 104",
        "1 <= k <= nums.length"
      ],
      "description": "You are given an integer array nums and an integer k. You can partition the array into at most k non-empty adjacent subarrays. The score of a partition is the sum of the averages of each subarray.\nNote that the partition must use every integer in nums, and that the score is not necessarily an integer.\nReturn the maximum score you can achieve of all the possible partitions. Answers within 10-6 of the actual answer will be accepted.\nExample 1:\nExample 2:\nConstraints:"
    },
    "length-of-longest-fibonacci-subsequence": {
      "questionId": "873",
      "title": "Length of Longest Fibonacci Subsequence",
      "difficulty": "Medium",
      "constraints": [
        "3 <= arr.length <= 1000",
        "1 <= arr[i] < arr[i + 1] <= 109"
      ],
      "description": "A sequence x1, x2, ..., xn is Fibonacci-like if:\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-common-subsequence": {
      "questionId": "1143",
      "title": "Longest Common Subsequence",
      "difficulty": "Medium",
      "constraints": [
        "1 <= text1.length, text2.length <= 1000",
        "text1 and text2 consist of only lowercase English characters."
      ],
      "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nA common subsequence of two strings is a subsequence that is common to both strings.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "longest-increasing-subsequence": {
      "questionId": "300",
      "title": "Longest Increasing Subsequence",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 2500",
        "-104 <= nums[i] <= 104"
      ],
      "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up:\u00a0Can you come up with an algorithm that runs in\u00a0O(n log(n)) time complexity?"
    },
    "longest-palindromic-subsequence": {
      "questionId": "516",
      "title": "Longest Palindromic Subsequence",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 1000",
        "s consists only of lowercase English letters."
      ],
      "description": "Given a string s, find the longest palindromic subsequence's length in s.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-turbulent-subarray": {
      "questionId": "978",
      "title": "Longest Turbulent Subarray",
      "difficulty": "Medium",
      "constraints": [
        "1 <= arr.length <= 4 * 104",
        "0 <= arr[i] <= 109"
      ],
      "description": "Given an integer array arr, return the length of a maximum size turbulent subarray of arr.\nA subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\nMore formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "matchsticks-to-square": {
      "questionId": "473",
      "title": "Matchsticks to Square",
      "difficulty": "Medium",
      "constraints": [
        "1 <= matchsticks.length <= 15",
        "1 <= matchsticks[i] <= 108"
      ],
      "description": "You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\nReturn true if you can make this square and false otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "maximal-square": {
      "questionId": "221",
      "title": "Maximal Square",
      "difficulty": "Medium",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 300",
        "matrix[i][j] is '0' or '1'."
      ],
      "description": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "maximum-length-of-pair-chain": {
      "questionId": "646",
      "title": "Maximum Length of Pair Chain",
      "difficulty": "Medium",
      "constraints": [
        "n == pairs.length",
        "1 <= n <= 1000",
        "-1000 <= lefti < righti <= 1000"
      ],
      "description": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\nA pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion.\nReturn the length longest chain which can be formed.\nYou do not need to use up all the given intervals. You can select pairs in any order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "maximum-product-subarray": {
      "questionId": "152",
      "title": "Maximum Product Subarray",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 2 * 104",
        "-10 <= nums[i] <= 10",
        "The product of any subarray of nums is guaranteed to fit in a 32-bit integer."
      ],
      "description": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.\nExample 1:\nExample 2:\nConstraints:"
    },
    "maximum-subarray": {
      "questionId": "53",
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "-104 <= nums[i] <= 104"
      ],
      "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle."
    },
    "maximum-sum-circular-subarray": {
      "questionId": "918",
      "title": "Maximum Sum Circular Subarray",
      "difficulty": "Medium",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 3 * 104",
        "-3 * 104 <= nums[i] <= 3 * 104"
      ],
      "description": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "min-cost-climbing-stairs": {
      "questionId": "746",
      "title": "Min Cost Climbing Stairs",
      "difficulty": "Easy",
      "constraints": [
        "2 <= cost.length <= 1000",
        "0 <= cost[i] <= 999"
      ],
      "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-ascii-delete-sum-for-two-strings": {
      "questionId": "712",
      "title": "Minimum ASCII Delete Sum for Two Strings",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s1.length, s2.length <= 1000",
        "s1 and s2 consist of lowercase English letters."
      ],
      "description": "Given two strings s1 and\u00a0s2, return the lowest ASCII sum of deleted characters to make two strings equal.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-cost-for-tickets": {
      "questionId": "983",
      "title": "Minimum Cost For Tickets",
      "difficulty": "Medium",
      "constraints": [
        "1 <= days.length <= 365",
        "1 <= days[i] <= 365",
        "days is in strictly increasing order.",
        "costs.length == 3",
        "1 <= costs[i] <= 1000"
      ],
      "description": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\nThe passes allow that many days of consecutive travel.\nReturn the minimum number of dollars you need to travel every day in the given list of days.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-falling-path-sum": {
      "questionId": "931",
      "title": "Minimum Falling Path Sum",
      "difficulty": "Medium",
      "constraints": [
        "n == matrix.length == matrix[i].length",
        "1 <= n <= 100",
        "-100 <= matrix[i][j] <= 100"
      ],
      "description": "Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-path-sum": {
      "questionId": "64",
      "title": "Minimum Path Sum",
      "difficulty": "Medium",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 200",
        "0 <= grid[i][j] <= 200"
      ],
      "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\nExample 2:\nConstraints:"
    },
    "number-of-longest-increasing-subsequence": {
      "questionId": "673",
      "title": "Number of Longest Increasing Subsequence",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 2000",
        "-106 <= nums[i] <= 106",
        "The answer is guaranteed to fit inside a 32-bit integer."
      ],
      "description": "Given an integer array\u00a0nums, return the number of longest increasing subsequences.\nNotice that the sequence has to be strictly increasing.\nExample 1:\nExample 2:\nConstraints:"
    },
    "ones-and-zeroes": {
      "questionId": "474",
      "title": "Ones and Zeroes",
      "difficulty": "Medium",
      "constraints": [
        "1 <= strs.length <= 600",
        "1 <= strs[i].length <= 100",
        "strs[i] consists only of digits '0' and '1'.",
        "1 <= m, n <= 100"
      ],
      "description": "You are given an array of binary strings strs and two integers m and n.\nReturn the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\nA set x is a subset of a set y if all elements of x are also elements of y.\nExample 1:\nExample 2:\nConstraints:"
    },
    "out-of-boundary-paths": {
      "questionId": "576",
      "title": "Out of Boundary Paths",
      "difficulty": "Medium",
      "constraints": [
        "1 <= m, n <= 50",
        "0 <= maxMove <= 50",
        "0 <= startRow < m",
        "0 <= startColumn < n"
      ],
      "description": "There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball.\nGiven the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.\nExample 1:\nExample 2:\nConstraints:"
    },
    "partition-equal-subset-sum": {
      "questionId": "416",
      "title": "Partition Equal Subset Sum",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 200",
        "1 <= nums[i] <= 100"
      ],
      "description": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "partition-to-k-equal-sum-subsets": {
      "questionId": "698",
      "title": "Partition to K Equal Sum Subsets",
      "difficulty": "Medium",
      "constraints": [
        "1 <= k <= nums.length <= 16",
        "1 <= nums[i] <= 104",
        "The frequency of each element is in the range [1, 4]."
      ],
      "description": "Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.\nExample 1:\nExample 2:\nConstraints:"
    },
    "pascals-triangle": {
      "questionId": "118",
      "title": "Pascal's Triangle",
      "difficulty": "Easy",
      "constraints": [
        "1 <= numRows <= 30"
      ],
      "description": "Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\nExample 2:\nConstraints:"
    },
    "pascals-triangle-ii": {
      "questionId": "119",
      "title": "Pascal's Triangle II",
      "difficulty": "Easy",
      "constraints": [
        "0 <= rowIndex <= 33"
      ],
      "description": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you optimize your algorithm to use only O(rowIndex) extra space?"
    },
    "perfect-squares": {
      "questionId": "279",
      "title": "Perfect Squares",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 104"
      ],
      "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\nExample 1:\nExample 2:\nConstraints:"
    },
    "range-sum-query-2d-immutable": {
      "questionId": "304",
      "title": "Range Sum Query 2D - Immutable",
      "difficulty": "Medium",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 200",
        "-104 <= matrix[i][j] <= 104",
        "0 <= row1 <= row2 < m",
        "0 <= col1 <= col2 < n",
        "At most 104 calls will be made to sumRegion."
      ],
      "description": "Given a 2D matrix matrix, handle multiple queries of the following type:\nImplement the NumMatrix class:\nYou must design an algorithm where sumRegion works on O(1) time complexity.\nExample 1:\nConstraints:"
    },
    "range-sum-query-immutable": {
      "questionId": "303",
      "title": "Range Sum Query - Immutable",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-105 <= nums[i] <= 105",
        "0 <= left <= right < nums.length",
        "At most 104 calls will be made to sumRange."
      ],
      "description": "Given an integer array nums, handle multiple queries of the following type:\nImplement the NumArray class:\nExample 1:\nConstraints:"
    },
    "shopping-offers": {
      "questionId": "638",
      "title": "Shopping Offers",
      "difficulty": "Medium",
      "constraints": [
        "n == price.length == needs.length",
        "1 <= n <= 6",
        "0 <= price[i], needs[i] <= 10",
        "1 <= special.length <= 100",
        "special[i].length == n + 1",
        "0 <= special[i][j] <= 50",
        "The input is generated that at least one of special[i][j] is non-zero for 0 <= j <= n - 1."
      ],
      "description": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\nYou are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy.\nYou are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer.\nReturn the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\nExample 1:\nExample 2:\nConstraints:"
    },
    "sum-of-subarray-minimums": {
      "questionId": "907",
      "title": "Sum of Subarray Minimums",
      "difficulty": "Medium",
      "constraints": [
        "1 <= arr.length <= 3 * 104",
        "1 <= arr[i] <= 3 * 104"
      ],
      "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\nExample 1:\nExample 2:\nConstraints:"
    },
    "target-sum": {
      "questionId": "494",
      "title": "Target Sum",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 20",
        "0 <= nums[i] <= 1000",
        "0 <= sum(nums[i]) <= 1000",
        "-1000 <= target <= 1000"
      ],
      "description": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\nReturn the number of different expressions that you can build, which evaluates to target.\nExample 1:\nExample 2:\nConstraints:"
    },
    "triangle": {
      "questionId": "120",
      "title": "Triangle",
      "difficulty": "Medium",
      "constraints": [
        "1 <= triangle.length <= 200",
        "triangle[0].length == 1",
        "triangle[i].length == triangle[i - 1].length + 1",
        "-104 <= triangle[i][j] <= 104"
      ],
      "description": "Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nExample 1:\nExample 2:\nConstraints:"
    },
    "unique-binary-search-trees-ii": {
      "questionId": "95",
      "title": "Unique Binary Search Trees II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 8"
      ],
      "description": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "unique-paths": {
      "questionId": "62",
      "title": "Unique Paths",
      "difficulty": "Medium",
      "constraints": [
        "1 <= m, n <= 100"
      ],
      "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:"
    },
    "unique-paths-ii": {
      "questionId": "63",
      "title": "Unique Paths II",
      "difficulty": "Medium",
      "constraints": [
        "m == obstacleGrid.length",
        "n == obstacleGrid[i].length",
        "1 <= m, n <= 100",
        "obstacleGrid[i][j] is 0 or 1."
      ],
      "description": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:"
    },
    "unique-substrings-in-wraparound-string": {
      "questionId": "467",
      "title": "Unique Substrings in Wraparound String",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 105",
        "s consists of lowercase English letters."
      ],
      "description": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so base will look like this:\nGiven a string s, return the number of unique non-empty substrings of s are present in base.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "valid-parenthesis-string": {
      "questionId": "678",
      "title": "Valid Parenthesis String",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 100",
        "s[i] is '(', ')' or '*'."
      ],
      "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "video-stitching": {
      "questionId": "1024",
      "title": "Video Stitching",
      "difficulty": "Medium",
      "constraints": [
        "1 <= clips.length <= 100",
        "0 <= starti <= endi <= 100",
        "1 <= time <= 100"
      ],
      "description": "You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths.\nEach video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi.\nWe can cut these clips into segments freely.\nReturn the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "wiggle-subsequence": {
      "questionId": "376",
      "title": "Wiggle Subsequence",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 1000",
        "0 <= nums[i] <= 1000"
      ],
      "description": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\nA subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\nGiven an integer array nums, return the length of the longest wiggle subsequence of nums.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve this in O(n) time?"
    },
    "word-break": {
      "questionId": "139",
      "title": "Word Break",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 300",
        "1 <= wordDict.length <= 1000",
        "1 <= wordDict[i].length <= 20",
        "s and wordDict[i] consist of only lowercase English letters.",
        "All the strings of wordDict are unique."
      ],
      "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "bitwise-ors-of-subarrays": {
      "questionId": "898",
      "title": "Bitwise ORs of Subarrays",
      "difficulty": "Medium",
      "constraints": [
        "1 <= arr.length <= 5 * 104",
        "0 <= arr[i] <= 109"
      ],
      "description": "Given an integer array arr, return the number of distinct bitwise ORs of all the non-empty subarrays of arr.\nThe bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    }
  }
}