{
  "topic": "binary-search",
  "problems": {
    "132-pattern": {
      "questionId": "456",
      "title": "132 Pattern",
      "difficulty": "Medium",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 2 * 105",
        "-109 <= nums[i] <= 109"
      ],
      "description": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].\nReturn true if there is a 132 pattern in nums, otherwise, return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "binary-search": {
      "questionId": "704",
      "title": "Binary Search",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-104 < nums[i], target < 104",
        "All the integers in nums are unique.",
        "nums is sorted in ascending order."
      ],
      "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nConstraints:"
    },
    "capacity-to-ship-packages-within-d-days": {
      "questionId": "1011",
      "title": "Capacity To Ship Packages Within D Days",
      "difficulty": "Medium",
      "constraints": [
        "1 <= days <= weights.length <= 5 * 104",
        "1 <= weights[i] <= 500"
      ],
      "description": "A conveyor belt has packages that must be shipped from one port to another within days days.\nThe ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "fair-candy-swap": {
      "questionId": "888",
      "title": "Fair Candy Swap",
      "difficulty": "Easy",
      "constraints": [
        "1 <= aliceSizes.length, bobSizes.length <= 104",
        "1 <= aliceSizes[i], bobSizes[j] <= 105",
        "Alice and Bob have a different total number of candies.",
        "There will be at least one valid answer for the given input."
      ],
      "description": "Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\nReturn an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "find-first-and-last-position-of-element-in-sorted-array": {
      "questionId": "34",
      "title": "Find First and Last Position of Element in Sorted Array",
      "difficulty": "Medium",
      "constraints": [
        "0 <= nums.length <= 105",
        "-109\u00a0<= nums[i]\u00a0<= 109",
        "nums is a non-decreasing array.",
        "-109\u00a0<= target\u00a0<= 109"
      ],
      "description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "find-minimum-in-rotated-sorted-array": {
      "questionId": "153",
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 5000",
        "-5000 <= nums[i] <= 5000",
        "All the integers of nums are unique.",
        "nums is sorted and rotated between 1 and n times."
      ],
      "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in\u00a0O(log n) time.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "find-peak-element": {
      "questionId": "162",
      "title": "Find Peak Element",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 1000",
        "-231 <= nums[i] <= 231 - 1",
        "nums[i] != nums[i + 1] for all valid i."
      ],
      "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nExample 2:\nConstraints:"
    },
    "find-smallest-letter-greater-than-target": {
      "questionId": "744",
      "title": "Find Smallest Letter Greater Than Target",
      "difficulty": "Easy",
      "constraints": [
        "2 <= letters.length <= 104",
        "letters[i] is a lowercase English letter.",
        "letters is sorted in non-decreasing order.",
        "letters contains at least two different characters.",
        "target is a lowercase English letter."
      ],
      "description": "You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.\nReturn the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "h-index-ii": {
      "questionId": "275",
      "title": "H-Index II",
      "difficulty": "Medium",
      "constraints": [
        "n == citations.length",
        "1 <= n <= 105",
        "0 <= citations[i] <= 1000",
        "citations is sorted in ascending order."
      ],
      "description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in non-descending order, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\nYou must write an algorithm that runs in logarithmic time.\nExample 1:\nExample 2:\nConstraints:"
    },
    "koko-eating-bananas": {
      "questionId": "875",
      "title": "Koko Eating Bananas",
      "difficulty": "Medium",
      "constraints": [
        "1 <= piles.length <= 104",
        "piles.length <= h <= 109",
        "1 <= piles[i] <= 109"
      ],
      "description": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "kth-smallest-element-in-a-sorted-matrix": {
      "questionId": "378",
      "title": "Kth Smallest Element in a Sorted Matrix",
      "difficulty": "Medium",
      "constraints": [
        "n == matrix.length == matrix[i].length",
        "1 <= n <= 300",
        "-109 <= matrix[i][j] <= 109",
        "All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.",
        "1 <= k <= n2"
      ],
      "description": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\nYou must find a solution with a memory complexity better than O(n2).\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "max-consecutive-ones-iii": {
      "questionId": "1004",
      "title": "Max Consecutive Ones III",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "nums[i] is either 0 or 1.",
        "0 <= k <= nums.length"
      ],
      "description": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\nExample 1:\nExample 2:\nConstraints:"
    },
    "maximum-length-of-repeated-subarray": {
      "questionId": "718",
      "title": "Maximum Length of Repeated Subarray",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums1.length, nums2.length <= 1000",
        "0 <= nums1[i], nums2[i] <= 100"
      ],
      "description": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-size-subarray-sum": {
      "questionId": "209",
      "title": "Minimum Size Subarray Sum",
      "difficulty": "Medium",
      "constraints": [
        "1 <= target <= 109",
        "1 <= nums.length <= 105",
        "1 <= nums[i] <= 104"
      ],
      "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "my-calendar-i": {
      "questionId": "729",
      "title": "My Calendar I",
      "difficulty": "Medium",
      "constraints": [
        "0 <= start < end <= 109",
        "At most 1000 calls will be made to book."
      ],
      "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.\nA double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).\nThe event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime <= x < endTime.\nImplement the MyCalendar class:\nExample 1:\nConstraints:"
    },
    "my-calendar-ii": {
      "questionId": "731",
      "title": "My Calendar II",
      "difficulty": "Medium",
      "constraints": [
        "0 <= start < end <= 109",
        "At most 1000 calls will be made to book."
      ],
      "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.\nA triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).\nThe event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime <= x < endTime.\nImplement the MyCalendarTwo class:\nExample 1:\nConstraints:"
    },
    "number-of-matching-subsequences": {
      "questionId": "792",
      "title": "Number of Matching Subsequences",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 5 * 104",
        "1 <= words.length <= 5000",
        "1 <= words[i].length <= 50",
        "s and words[i] consist of only lowercase English letters."
      ],
      "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nExample 1:\nExample 2:\nConstraints:"
    },
    "online-election": {
      "questionId": "911",
      "title": "Online Election",
      "difficulty": "Medium",
      "constraints": [
        "1 <= persons.length <= 5000",
        "times.length == persons.length",
        "0 <= persons[i] < persons.length",
        "0 <= times[i] <= 109",
        "times is sorted in a strictly increasing order.",
        "times[0] <= t <= 109",
        "At most 104 calls will be made to q."
      ],
      "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\nExample 1:\nConstraints:"
    },
    "peak-index-in-a-mountain-array": {
      "questionId": "852",
      "title": "Peak Index in a Mountain Array",
      "difficulty": "Medium",
      "constraints": [
        "3 <= arr.length <= 105",
        "0 <= arr[i] <= 106",
        "arr is guaranteed to be a mountain array."
      ],
      "description": "You are given an integer mountain array arr of length n where the values increase to a peak element and then decrease.\nReturn the index of the peak element.\nYour task is to solve it in O(log(n)) time complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "search-a-2d-matrix": {
      "questionId": "74",
      "title": "Search a 2D Matrix",
      "difficulty": "Medium",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 100",
        "-104 <= matrix[i][j], target <= 104"
      ],
      "description": "You are given an m x n integer matrix matrix with the following two properties:\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nExample 2:\nConstraints:"
    },
    "search-a-2d-matrix-ii": {
      "questionId": "240",
      "title": "Search a 2D Matrix II",
      "difficulty": "Medium",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= n, m <= 300",
        "-109 <= matrix[i][j] <= 109",
        "All the integers in each row are sorted in ascending order.",
        "All the integers in each column are sorted in ascending order.",
        "-109 <= target <= 109"
      ],
      "description": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\nExample 1:\nExample 2:\nConstraints:"
    },
    "search-in-rotated-sorted-array": {
      "questionId": "33",
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 5000",
        "-104 <= nums[i] <= 104",
        "All values of nums are unique.",
        "nums is an ascending array that is possibly rotated.",
        "-104 <= target <= 104"
      ],
      "description": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "search-in-rotated-sorted-array-ii": {
      "questionId": "81",
      "title": "Search in Rotated Sorted Array II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 5000",
        "-104 <= nums[i] <= 104",
        "nums is guaranteed to be rotated at some pivot.",
        "-104 <= target <= 104"
      ],
      "description": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nExample 2:\nConstraints:\nFollow up: This problem is similar to\u00a0Search in Rotated Sorted Array, but\u00a0nums may contain duplicates. Would this affect the runtime complexity? How and why?"
    },
    "search-insert-position": {
      "questionId": "35",
      "title": "Search Insert Position",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-104 <= nums[i] <= 104",
        "nums contains distinct values sorted in ascending order.",
        "-104 <= target <= 104"
      ],
      "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "single-element-in-a-sorted-array": {
      "questionId": "540",
      "title": "Single Element in a Sorted Array",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 105"
      ],
      "description": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\nReturn the single element that appears only once.\nYour solution must run in O(log n) time and O(1) space.\nExample 1:\nExample 2:\nConstraints:"
    },
    "subarray-product-less-than-k": {
      "questionId": "713",
      "title": "Subarray Product Less Than K",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 3 * 104",
        "1 <= nums[i] <= 1000",
        "0 <= k <= 106"
      ],
      "description": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\nExample 1:\nExample 2:\nConstraints:"
    },
    "time-based-key-value-store": {
      "questionId": "981",
      "title": "Time Based Key-Value Store",
      "difficulty": "Medium",
      "constraints": [
        "1 <= key.length, value.length <= 100",
        "key and value consist of lowercase English letters and digits.",
        "1 <= timestamp <= 107",
        "All the timestamps timestamp of set are strictly increasing.",
        "At most 2 * 105 calls will be made to set and get."
      ],
      "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\nImplement the TimeMap class:\nExample 1:\nConstraints:"
    }
  }
}