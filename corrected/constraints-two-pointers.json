{
  "topic": "two-pointers",
  "problems": {
    "3sum": {
      "questionId": "15",
      "title": "3Sum",
      "difficulty": "Medium",
      "constraints": [
        "3 <= nums.length <= 3000",
        "-105 <= nums[i] <= 105"
      ],
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "3sum-closest": {
      "questionId": "16",
      "title": "3Sum Closest",
      "difficulty": "Medium",
      "constraints": [
        "3 <= nums.length <= 500",
        "-1000 <= nums[i] <= 1000",
        "-104 <= target <= 104"
      ],
      "description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\nExample 1:\nExample 2:\nConstraints:"
    },
    "3sum-with-multiplicity": {
      "questionId": "923",
      "title": "3Sum With Multiplicity",
      "difficulty": "Medium",
      "constraints": [
        "3 <= arr.length <= 3000",
        "0 <= arr[i] <= 100",
        "0 <= target <= 300"
      ],
      "description": "Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.\nAs the answer can be very large, return it modulo 109 + 7.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "4sum": {
      "questionId": "18",
      "title": "4Sum",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 200",
        "-109 <= nums[i] <= 109",
        "-109 <= target <= 109"
      ],
      "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\nYou may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "advantage-shuffle": {
      "questionId": "870",
      "title": "Advantage Shuffle",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums1.length <= 105",
        "nums2.length == nums1.length",
        "0 <= nums1[i], nums2[i] <= 109"
      ],
      "description": "You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] > nums2[i].\nReturn any permutation of nums1 that maximizes its advantage with respect to nums2.\nExample 1:\nExample 2:\nConstraints:"
    },
    "assign-cookies": {
      "questionId": "455",
      "title": "Assign Cookies",
      "difficulty": "Easy",
      "constraints": [
        "1 <= g.length <= 3 * 104",
        "0 <= s.length <= 3 * 104",
        "1 <= g[i], s[j] <= 231 - 1"
      ],
      "description": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nExample 1:\nExample 2:\nConstraints:\nNote: This question is the same as  2410: Maximum Matching of Players With Trainers."
    },
    "backspace-string-compare": {
      "questionId": "844",
      "title": "Backspace String Compare",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length, t.length <= 200",
        "s and t only contain lowercase letters and '#' characters."
      ],
      "description": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\nNote that after backspacing an empty text, the text will continue empty.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you solve it in O(n) time and O(1) space?"
    },
    "bag-of-tokens": {
      "questionId": "948",
      "title": "Bag of Tokens",
      "difficulty": "Medium",
      "constraints": [
        "0 <= tokens.length <= 1000",
        "0 <= tokens[i], power < 104"
      ],
      "description": "You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each\u00a0tokens[i] denotes the value of tokeni.\nYour goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token):\nReturn the maximum possible score you can achieve after playing any number of tokens.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "boats-to-save-people": {
      "questionId": "881",
      "title": "Boats to Save People",
      "difficulty": "Medium",
      "constraints": [
        "1 <= people.length <= 5 * 104",
        "1 <= people[i] <= limit <= 3 * 104"
      ],
      "description": "You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "camelcase-matching": {
      "questionId": "1023",
      "title": "Camelcase Matching",
      "difficulty": "Medium",
      "constraints": [
        "1 <= pattern.length, queries.length <= 100",
        "1 <= queries[i].length <= 100",
        "queries[i] and pattern consist of English letters."
      ],
      "description": "Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise.\nA query word queries[i] matches pattern if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters at all.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "circular-array-loop": {
      "questionId": "457",
      "title": "Circular Array Loop",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 5000",
        "-1000 <= nums[i] <= 1000",
        "nums[i] != 0"
      ],
      "description": "You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:\nSince the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.\nA cycle in the array consists of a sequence of indices seq of length k where:\nReturn true if there is a cycle in nums, or false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve it in O(n) time complexity and O(1) extra space complexity?"
    },
    "compare-version-numbers": {
      "questionId": "165",
      "title": "Compare Version Numbers",
      "difficulty": "Medium",
      "constraints": [
        "1 <= version1.length, version2.length <= 500",
        "version1 and version2\u00a0only contain digits and '.'.",
        "version1 and version2\u00a0are valid version numbers.",
        "All the given revisions in\u00a0version1 and version2\u00a0can be stored in\u00a0a\u00a032-bit integer."
      ],
      "description": "Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros.\nTo compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0.\nReturn the following:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "container-with-most-water": {
      "questionId": "11",
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "constraints": [
        "n == height.length",
        "2 <= n <= 105",
        "0 <= height[i] <= 104"
      ],
      "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\nExample 1:\nExample 2:\nConstraints:"
    },
    "count-binary-substrings": {
      "questionId": "696",
      "title": "Count Binary Substrings",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 105",
        "s[i] is either '0' or '1'."
      ],
      "description": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\nSubstrings that occur multiple times are counted the number of times they occur.\nExample 1:\nExample 2:\nConstraints:"
    },
    "di-string-match": {
      "questionId": "942",
      "title": "DI String Match",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 105",
        "s[i] is either 'I' or 'D'."
      ],
      "description": "A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where:\nGiven a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "expressive-words": {
      "questionId": "809",
      "title": "Expressive Words",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length, words.length <= 100",
        "1 <= words[i].length <= 100",
        "s and words[i] consist of lowercase letters."
      ],
      "description": "Sometimes people repeat letters to represent extra feeling. For example:\nIn these strings like \"heeellooo\", we have groups of adjacent letters that are all the same: \"h\", \"eee\", \"ll\", \"ooo\".\nYou are given a string s and an array of query strings words. A query word is stretchy if it can be made to be equal to s by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is three or more.\nReturn the number of query strings that are stretchy.\nExample 1:\nExample 2:\nConstraints:"
    },
    "find-k-closest-elements": {
      "questionId": "658",
      "title": "Find K Closest Elements",
      "difficulty": "Medium",
      "constraints": [
        "1 <= k <= arr.length",
        "1 <= arr.length <= 104",
        "arr is sorted in ascending order.",
        "-104 <= arr[i], x <= 104"
      ],
      "description": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\nAn integer a is closer to x than an integer b if:\nExample 1:\nExample 2:\nConstraints:"
    },
    "find-the-duplicate-number": {
      "questionId": "287",
      "title": "Find the Duplicate Number",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 105",
        "nums.length == n + 1",
        "1 <= nums[i] <= n",
        "All the integers in nums appear only once except for precisely one integer which appears two or more times."
      ],
      "description": "Given an array of integers nums containing\u00a0n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this\u00a0repeated\u00a0number.\nYou must solve the problem without modifying the array nums\u00a0and using only constant extra space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up:"
    },
    "find-the-index-of-the-first-occurrence-in-a-string": {
      "questionId": "28",
      "title": "Find the Index of the First Occurrence in a String",
      "difficulty": "Easy",
      "constraints": [
        "1 <= haystack.length, needle.length <= 104",
        "haystack and needle consist of only lowercase English characters."
      ],
      "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\nExample 2:\nConstraints:"
    },
    "flipping-an-image": {
      "questionId": "832",
      "title": "Flipping an Image",
      "difficulty": "Easy",
      "constraints": [
        "n == image.length",
        "n == image[i].length",
        "1 <= n <= 20",
        "images[i][j] is either 0 or 1."
      ],
      "description": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed.\nTo invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\nExample 1:\nExample 2:\nConstraints:"
    },
    "friends-of-appropriate-ages": {
      "questionId": "825",
      "title": "Friends Of Appropriate Ages",
      "difficulty": "Medium",
      "constraints": [
        "n == ages.length",
        "1 <= n <= 2 * 104",
        "1 <= ages[i] <= 120"
      ],
      "description": "There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person.\nA Person x will not send a friend request to a person y (x != y) if any of the following conditions is true:\nOtherwise, x will send a friend request to y.\nNote that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself.\nReturn the total number of friend requests made.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "heaters": {
      "questionId": "475",
      "title": "Heaters",
      "difficulty": "Medium",
      "constraints": [
        "1 <= houses.length, heaters.length <= 3 * 104",
        "1 <= houses[i], heaters[i] <= 109"
      ],
      "description": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.\nEvery house can be warmed, as long as the house is within the heater's warm radius range.\nGiven the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters\u00a0so that those heaters could cover all houses.\nNotice that\u00a0all the heaters follow your radius standard, and the warm radius will the same.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "intersection-of-two-arrays": {
      "questionId": "349",
      "title": "Intersection of Two Arrays",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums1.length, nums2.length <= 1000",
        "0 <= nums1[i], nums2[i] <= 1000"
      ],
      "description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "intersection-of-two-arrays-ii": {
      "questionId": "350",
      "title": "Intersection of Two Arrays II",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums1.length, nums2.length <= 1000",
        "0 <= nums1[i], nums2[i] <= 1000"
      ],
      "description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "interval-list-intersections": {
      "questionId": "986",
      "title": "Interval List Intersections",
      "difficulty": "Medium",
      "constraints": [
        "0 <= firstList.length, secondList.length <= 1000",
        "firstList.length + secondList.length >= 1",
        "0 <= starti < endi <= 109",
        "endi < starti+1",
        "0 <= startj < endj <= 109",
        "endj < startj+1"
      ],
      "description": "You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order.\nReturn the intersection of these two interval lists.\nA closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.\nThe intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].\nExample 1:\nExample 2:\nConstraints:"
    },
    "is-subsequence": {
      "questionId": "392",
      "title": "Is Subsequence",
      "difficulty": "Easy",
      "constraints": [
        "0 <= s.length <= 100",
        "0 <= t.length <= 104",
        "s and t consist only of lowercase English letters."
      ],
      "description": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\nExample 1:\nExample 2:\nConstraints:"
    },
    "k-diff-pairs-in-an-array": {
      "questionId": "532",
      "title": "K-diff Pairs in an Array",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 104",
        "-107 <= nums[i] <= 107",
        "0 <= k <= 107"
      ],
      "description": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\nNotice that |val| denotes the absolute value of val.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "k-th-smallest-prime-fraction": {
      "questionId": "786",
      "title": "K-th Smallest Prime Fraction",
      "difficulty": "Medium",
      "constraints": [
        "2 <= arr.length <= 1000",
        "1 <= arr[i] <= 3 * 104",
        "arr[0] == 1",
        "arr[i] is a prime number for i > 0.",
        "All the numbers of arr are unique and sorted in strictly increasing order.",
        "1 <= k <= arr.length * (arr.length - 1) / 2"
      ],
      "description": "You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.\nFor every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].\nReturn the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].\nExample 1:\nExample 2:\nConstraints:"
    },
    "long-pressed-name": {
      "questionId": "925",
      "title": "Long Pressed Name",
      "difficulty": "Easy",
      "constraints": [
        "1 <= name.length, typed.length <= 1000",
        "name and typed consist of only lowercase English letters."
      ],
      "description": "Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-mountain-in-array": {
      "questionId": "845",
      "title": "Longest Mountain in Array",
      "difficulty": "Medium",
      "constraints": [
        "1 <= arr.length <= 104",
        "0 <= arr[i] <= 104"
      ],
      "description": "You may recall that an array arr is a mountain array if and only if:\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "longest-palindromic-substring": {
      "questionId": "5",
      "title": "Longest Palindromic Substring",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 1000",
        "s consist of only digits and English letters."
      ],
      "description": "Given a string s, return the longest palindromic substring in s.\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-uncommon-subsequence-ii": {
      "questionId": "522",
      "title": "Longest Uncommon Subsequence II",
      "difficulty": "Medium",
      "constraints": [
        "2 <= strs.length <= 50",
        "1 <= strs[i].length <= 10",
        "strs[i] consists of lowercase English letters."
      ],
      "description": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.\nAn uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-word-in-dictionary-through-deleting": {
      "questionId": "524",
      "title": "Longest Word in Dictionary through Deleting",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 1000",
        "1 <= dictionary.length <= 1000",
        "1 <= dictionary[i].length <= 1000",
        "s and dictionary[i] consist of lowercase English letters."
      ],
      "description": "Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\nExample 1:\nExample 2:\nConstraints:"
    },
    "magical-string": {
      "questionId": "481",
      "title": "Magical String",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 105"
      ],
      "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\nExample 1:\nExample 2:\nConstraints:"
    },
    "maximum-width-ramp": {
      "questionId": "962",
      "title": "Maximum Width Ramp",
      "difficulty": "Medium",
      "constraints": [
        "2 <= nums.length <= 5 * 104",
        "0 <= nums[i] <= 5 * 104"
      ],
      "description": "A ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] <= nums[j]. The width of such a ramp is j - i.\nGiven an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.\nExample 1:\nExample 2:\nConstraints:"
    },
    "merge-sorted-array": {
      "questionId": "88",
      "title": "Merge Sorted Array",
      "difficulty": "Easy",
      "constraints": [
        "nums1.length == m + n",
        "nums2.length == n",
        "0 <= m, n <= 200",
        "1 <= m + n <= 200",
        "-109 <= nums1[i], nums2[j] <= 109"
      ],
      "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?"
    },
    "most-profit-assigning-work": {
      "questionId": "826",
      "title": "Most Profit Assigning Work",
      "difficulty": "Medium",
      "constraints": [
        "n == difficulty.length",
        "n == profit.length",
        "m == worker.length",
        "1 <= n, m <= 104",
        "1 <= difficulty[i], profit[i], worker[i] <= 105"
      ],
      "description": "You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\nExample 1:\nExample 2:\nConstraints:"
    },
    "move-zeroes": {
      "questionId": "283",
      "title": "Move Zeroes",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-231 <= nums[i] <= 231 - 1"
      ],
      "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\nExample 1:\nExample 2:\nConstraints:"
    },
    "next-permutation": {
      "questionId": "31",
      "title": "Next Permutation",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 100",
        "0 <= nums[i] <= 100"
      ],
      "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "number-of-subarrays-with-bounded-maximum": {
      "questionId": "795",
      "title": "Number of Subarrays with Bounded Maximum",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 109",
        "0 <= left <= right <= 109"
      ],
      "description": "Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right].\nThe test cases are generated so that the answer will fit in a 32-bit integer.\nExample 1:\nExample 2:\nConstraints:"
    },
    "palindromic-substrings": {
      "questionId": "647",
      "title": "Palindromic Substrings",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 1000",
        "s consists of lowercase English letters."
      ],
      "description": "Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.\nExample 1:\nExample 2:\nConstraints:"
    },
    "pancake-sorting": {
      "questionId": "969",
      "title": "Pancake Sorting",
      "difficulty": "Medium",
      "constraints": [
        "1 <= arr.length <= 100",
        "1 <= arr[i] <= arr.length",
        "All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length)."
      ],
      "description": "Given an array of integers arr, sort the array by performing a series of pancake flips.\nIn one pancake flip we do the following steps:\nFor example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.\nReturn an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.\nExample 1:\nExample 2:\nConstraints:"
    },
    "push-dominoes": {
      "questionId": "838",
      "title": "Push Dominoes",
      "difficulty": "Medium",
      "constraints": [
        "n == dominoes.length",
        "1 <= n <= 105",
        "dominoes[i] is either 'L', 'R', or '.'."
      ],
      "description": "There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\nYou are given a string dominoes representing the initial state where:\nReturn a string representing the final state.\nExample 1:\nExample 2:\nConstraints:"
    },
    "remove-duplicates-from-sorted-array": {
      "questionId": "26",
      "title": "Remove Duplicates from Sorted Array",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 3 * 104",
        "-100 <= nums[i] <= 100",
        "nums is sorted in non-decreasing order."
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:"
    },
    "remove-duplicates-from-sorted-array-ii": {
      "questionId": "80",
      "title": "Remove Duplicates from Sorted Array II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 3 * 104",
        "-104 <= nums[i] <= 104",
        "nums is sorted in non-decreasing order."
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:"
    },
    "remove-element": {
      "questionId": "27",
      "title": "Remove Element",
      "difficulty": "Easy",
      "constraints": [
        "0 <= nums.length <= 100",
        "0 <= nums[i] <= 50",
        "0 <= val <= 100"
      ],
      "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:"
    },
    "reverse-only-letters": {
      "questionId": "917",
      "title": "Reverse Only Letters",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 100",
        "s consists of characters with ASCII values in the range [33, 122].",
        "s does not contain '\\\"' or '\\\\'."
      ],
      "description": "Given a string s, reverse the string according to the following rules:\nReturn s after reversing it.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "reverse-string": {
      "questionId": "344",
      "title": "Reverse String",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 105",
        "s[i] is a printable ascii character."
      ],
      "description": "Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\nExample 2:\nConstraints:"
    },
    "reverse-string-ii": {
      "questionId": "541",
      "title": "Reverse String II",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 104",
        "s consists of only lowercase English letters.",
        "1 <= k <= 104"
      ],
      "description": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\nExample 1:\nExample 2:\nConstraints:"
    },
    "reverse-vowels-of-a-string": {
      "questionId": "345",
      "title": "Reverse Vowels of a String",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 3 * 105",
        "s consist of printable ASCII characters."
      ],
      "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\nExample 1:\nExample 2:\nConstraints:"
    },
    "reverse-words-in-a-string": {
      "questionId": "151",
      "title": "Reverse Words in a String",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 104",
        "s contains English letters (upper-case and lower-case), digits, and spaces ' '.",
        "There is at least one word in s."
      ],
      "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?"
    },
    "reverse-words-in-a-string-iii": {
      "questionId": "557",
      "title": "Reverse Words in a String III",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 5 * 104",
        "s contains printable ASCII characters.",
        "s does not contain any leading or trailing spaces.",
        "There is at least one word in s.",
        "All the words in s are separated by a single space."
      ],
      "description": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "rotate-array": {
      "questionId": "189",
      "title": "Rotate Array",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "-231 <= nums[i] <= 231 - 1",
        "0 <= k <= 105"
      ],
      "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "shortest-distance-to-a-character": {
      "questionId": "821",
      "title": "Shortest Distance to a Character",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 104",
        "s[i] and c are lowercase English letters.",
        "It is guaranteed that c occurs at least once in s."
      ],
      "description": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\nExample 1:\nExample 2:\nConstraints:"
    },
    "shortest-unsorted-continuous-subarray": {
      "questionId": "581",
      "title": "Shortest Unsorted Continuous Subarray",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 104",
        "-105 <= nums[i] <= 105"
      ],
      "description": "Given an integer array nums, you need to find one continuous subarray such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.\nReturn the shortest such subarray and output its length.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "sort-array-by-parity": {
      "questionId": "905",
      "title": "Sort Array By Parity",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 5000",
        "0 <= nums[i] <= 5000"
      ],
      "description": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.\nReturn any array that satisfies this condition.\nExample 1:\nExample 2:\nConstraints:"
    },
    "sort-array-by-parity-ii": {
      "questionId": "922",
      "title": "Sort Array By Parity II",
      "difficulty": "Easy",
      "constraints": [
        "2 <= nums.length <= 2 * 104",
        "nums.length is even.",
        "Half of the integers in nums are even.",
        "0 <= nums[i] <= 1000"
      ],
      "description": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.\nExample 1:\nExample 2:\nConstraints:\nFollow Up: Could you solve it in-place?"
    },
    "sort-colors": {
      "questionId": "75",
      "title": "Sort Colors",
      "difficulty": "Medium",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 300",
        "nums[i] is either 0, 1, or 2."
      ],
      "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\nExample 1:\nExample 2:\nConstraints:\nFollow up:\u00a0Could you come up with a one-pass algorithm using only\u00a0constant extra space?"
    },
    "squares-of-a-sorted-array": {
      "questionId": "977",
      "title": "Squares of a Sorted Array",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-104 <= nums[i] <= 104",
        "nums is sorted in non-decreasing order."
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "string-compression": {
      "questionId": "443",
      "title": "String Compression",
      "difficulty": "Medium",
      "constraints": [
        "1 <= chars.length <= 2000",
        "chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol."
      ],
      "description": "Given an array of characters chars, compress it using the following algorithm:\nBegin with an empty string s. For each group of consecutive repeating characters in chars:\nThe compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\nAfter you are done modifying the input array, return the new length of the array.\nYou must write an algorithm that uses only constant extra space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "swap-adjacent-in-lr-string": {
      "questionId": "777",
      "title": "Swap Adjacent in LR String",
      "difficulty": "Medium",
      "constraints": [
        "1 <= start.length\u00a0<= 104",
        "start.length == result.length",
        "Both start and result will only consist of characters in 'L', 'R', and\u00a0'X'."
      ],
      "description": "In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string result, return True if and only if there exists a sequence of moves to transform start to result.\nExample 1:\nExample 2:\nConstraints:"
    },
    "trapping-rain-water": {
      "questionId": "42",
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "constraints": [
        "n == height.length",
        "1 <= n <= 2 * 104",
        "0 <= height[i] <= 105"
      ],
      "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nExample 2:\nConstraints:"
    },
    "two-sum-ii-input-array-is-sorted": {
      "questionId": "167",
      "title": "Two Sum II - Input Array Is Sorted",
      "difficulty": "Medium",
      "constraints": [
        "2 <= numbers.length <= 3 * 104",
        "-1000 <= numbers[i] <= 1000",
        "numbers is sorted in non-decreasing order.",
        "-1000 <= target <= 1000",
        "The tests are generated such that there is exactly one solution."
      ],
      "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "two-sum-iv-input-is-a-bst": {
      "questionId": "653",
      "title": "Two Sum IV - Input is a BST",
      "difficulty": "Easy",
      "constraints": [
        "The number of nodes in the tree is in the range [1, 104].",
        "-104 <= Node.val <= 104",
        "root is guaranteed to be a valid binary search tree.",
        "-105 <= k <= 105"
      ],
      "description": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "valid-palindrome": {
      "questionId": "125",
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 2 * 105",
        "s consists only of printable ASCII characters."
      ],
      "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "valid-palindrome-ii": {
      "questionId": "680",
      "title": "Valid Palindrome II",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 105",
        "s consists of lowercase English letters."
      ],
      "description": "Given a string s, return true if the s can be palindrome after deleting at most one character from it.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "valid-triangle-number": {
      "questionId": "611",
      "title": "Valid Triangle Number",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 1000",
        "0 <= nums[i] <= 1000"
      ],
      "description": "Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\nExample 1:\nExample 2:\nConstraints:"
    }
  }
}