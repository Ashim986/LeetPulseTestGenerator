{
  "topic": "arrays-hashing",
  "problems": {
    "1-bit-and-2-bit-characters": {
      "questionId": "717",
      "title": "1-bit and 2-bit Characters",
      "difficulty": "Easy",
      "constraints": [
        "1 <= bits.length <= 1000",
        "bits[i] is either 0 or 1."
      ],
      "description": "We have two special characters:\nGiven a binary array bits that ends with 0, return true if the last character must be a one-bit character.\nExample 1:\nExample 2:\nConstraints:"
    },
    "4sum-ii": {
      "questionId": "454",
      "title": "4Sum II",
      "difficulty": "Medium",
      "constraints": [
        "n == nums1.length",
        "n == nums2.length",
        "n == nums3.length",
        "n == nums4.length",
        "1 <= n <= 200",
        "-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228"
      ],
      "description": "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\nExample 1:\nExample 2:\nConstraints:"
    },
    "array-nesting": {
      "questionId": "565",
      "title": "Array Nesting",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] < nums.length",
        "All the values of nums are unique."
      ],
      "description": "You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\nYou should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\nReturn the longest length of a set s[k].\nExample 1:\nExample 2:\nConstraints:"
    },
    "available-captures-for-rook": {
      "questionId": "999",
      "title": "Available Captures for Rook",
      "difficulty": "Easy",
      "constraints": [
        "board.length == 8",
        "board[i].length == 8",
        "board[i][j] is either 'R', '.', 'B', or 'p'",
        "There is exactly one cell with board[i][j] == 'R'"
      ],
      "description": "You are given an 8 x 8 matrix representing a chessboard. There is exactly one white rook represented by 'R', some number of white bishops 'B', and some number of black pawns 'p'. Empty squares are represented by '.'.\nA rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece or the edge of the board. A rook is attacking a pawn if it can move to the pawn's square in one move.\nNote: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path.\nReturn the number of pawns the white rook is attacking.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "battleships-in-a-board": {
      "questionId": "419",
      "title": "Battleships in a Board",
      "difficulty": "Medium",
      "constraints": [
        "m == board.length",
        "n == board[i].length",
        "1 <= m, n <= 200",
        "board[i][j] is either '.' or 'X'."
      ],
      "description": "Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.\nBattleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\nExample 1:\nExample 2:\nConstraints:\nFollow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the values board?"
    },
    "brick-wall": {
      "questionId": "554",
      "title": "Brick Wall",
      "difficulty": "Medium",
      "constraints": [
        "n == wall.length",
        "1 <= n <= 104",
        "1 <= wall[i].length <= 104",
        "1 <= sum(wall[i].length) <= 2 * 104",
        "sum(wall[i]) is the same for each row i.",
        "1 <= wall[i][j] <= 231 - 1"
      ],
      "description": "There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.\nDraw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\nGiven the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.\nExample 1:\nExample 2:\nConstraints:"
    },
    "buddy-strings": {
      "questionId": "859",
      "title": "Buddy Strings",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length, goal.length <= 2 * 104",
        "s and goal consist of lowercase letters."
      ],
      "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "bulls-and-cows": {
      "questionId": "299",
      "title": "Bulls and Cows",
      "difficulty": "Medium",
      "constraints": [
        "1 <= secret.length, guess.length <= 1000",
        "secret.length == guess.length",
        "secret and guess consist of digits only."
      ],
      "description": "You are playing the Bulls and Cows game with your friend.\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\nGiven the secret number secret and your friend's guess guess, return the hint for your friend's guess.\nThe hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\nExample 1:\nExample 2:\nConstraints:"
    },
    "card-flipping-game": {
      "questionId": "822",
      "title": "Card Flipping Game",
      "difficulty": "Medium",
      "constraints": [
        "n == fronts.length == backs.length",
        "1 <= n <= 1000",
        "1 <= fronts[i], backs[i] <= 2000"
      ],
      "description": "You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero).\nAfter flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card.\nReturn the minimum possible good integer after flipping the cards. If there are no good integers, return 0.\nExample 1:\nExample 2:\nConstraints:"
    },
    "contains-duplicate": {
      "questionId": "217",
      "title": "Contains Duplicate",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 105",
        "-109 <= nums[i] <= 109"
      ],
      "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "contiguous-array": {
      "questionId": "525",
      "title": "Contiguous Array",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "nums[i] is either 0 or 1."
      ],
      "description": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "custom-sort-string": {
      "questionId": "791",
      "title": "Custom Sort String",
      "difficulty": "Medium",
      "constraints": [
        "1 <= order.length <= 26",
        "1 <= s.length <= 200",
        "order and s consist of lowercase English letters.",
        "All the characters of order are unique."
      ],
      "description": "You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.\nPermute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.\nReturn any permutation of s that satisfies this property.\nExample 1:\nExample 2:\nConstraints:"
    },
    "degree-of-an-array": {
      "questionId": "697",
      "title": "Degree of an Array",
      "difficulty": "Easy",
      "constraints": [
        "nums.length will be between 1 and 50,000.",
        "nums[i] will be an integer between 0 and 49,999."
      ],
      "description": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\nYour task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\nExample 1:\nExample 2:\nConstraints:"
    },
    "delete-columns-to-make-sorted": {
      "questionId": "944",
      "title": "Delete Columns to Make Sorted",
      "difficulty": "Easy",
      "constraints": [
        "n == strs.length",
        "1 <= n <= 100",
        "1 <= strs[i].length <= 1000",
        "strs[i] consists of lowercase English letters."
      ],
      "description": "You are given an array of n strings strs, all of the same length.\nThe strings can be arranged such that there is one on each line, making a grid.\nYou want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\nReturn the number of columns that you will delete.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "diagonal-traverse": {
      "questionId": "498",
      "title": "Diagonal Traverse",
      "difficulty": "Medium",
      "constraints": [
        "m == mat.length",
        "n == mat[i].length",
        "1 <= m, n <= 104",
        "1 <= m * n <= 104",
        "-105 <= mat[i][j] <= 105"
      ],
      "description": "Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "distribute-candies": {
      "questionId": "575",
      "title": "Distribute Candies",
      "difficulty": "Easy",
      "constraints": [
        "n == candyType.length",
        "2 <= n <= 104",
        "n\u00a0is even.",
        "-105 <= candyType[i] <= 105"
      ],
      "description": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "encode-and-decode-tinyurl": {
      "questionId": "535",
      "title": "Encode and Decode TinyURL",
      "difficulty": "Medium",
      "constraints": [
        "1 <= url.length <= 104",
        "url is guranteed to be a valid URL."
      ],
      "description": "TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\nImplement the Solution class:\nExample 1:\nConstraints:"
    },
    "find-all-duplicates-in-an-array": {
      "questionId": "442",
      "title": "Find All Duplicates in an Array",
      "difficulty": "Medium",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 105",
        "1 <= nums[i] <= n",
        "Each element in nums appears once or twice."
      ],
      "description": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears at most twice, return an array of all the integers that appears twice.\nYou must write an algorithm that runs in O(n) time and uses only constant auxiliary space, excluding the space needed to store the output\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "find-all-numbers-disappeared-in-an-array": {
      "questionId": "448",
      "title": "Find All Numbers Disappeared in an Array",
      "difficulty": "Easy",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 105",
        "1 <= nums[i] <= n"
      ],
      "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\nExample 1:\nExample 2:\nConstraints:\nFollow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space."
    },
    "find-and-replace-in-string": {
      "questionId": "833",
      "title": "Find And Replace in String",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 1000",
        "k == indices.length == sources.length == targets.length",
        "1 <= k <= 100",
        "0 <= indexes[i] < s.length",
        "1 <= sources[i].length, targets[i].length <= 50",
        "s consists of only lowercase English letters.",
        "sources[i] and targets[i] consist of only lowercase English letters."
      ],
      "description": "You are given a 0-indexed string s that you must perform k replacement operations on. The replacement operations are given as three 0-indexed parallel arrays, indices, sources, and targets, all of length k.\nTo complete the ith replacement operation:\nFor example, if s = \"abcd\", indices[i] = 0, sources[i] = \"ab\", and targets[i] = \"eee\", then the result of this replacement will be \"eeecd\".\nAll replacement operations must occur simultaneously, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will not overlap.\nReturn the resulting string after performing all replacement operations on s.\nA substring is a contiguous sequence of characters in a string.\nExample 1:\nExample 2:\nConstraints:"
    },
    "find-and-replace-pattern": {
      "questionId": "890",
      "title": "Find and Replace Pattern",
      "difficulty": "Medium",
      "constraints": [
        "1 <= pattern.length <= 20",
        "1 <= words.length <= 50",
        "words[i].length == pattern.length",
        "pattern and words[i] are lowercase English letters."
      ],
      "description": "Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.\nExample 1:\nExample 2:\nConstraints:"
    },
    "find-common-characters": {
      "questionId": "1002",
      "title": "Find Common Characters",
      "difficulty": "Easy",
      "constraints": [
        "1 <= words.length <= 100",
        "1 <= words[i].length <= 100",
        "words[i] consists of lowercase English letters."
      ],
      "description": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "find-duplicate-file-in-system": {
      "questionId": "609",
      "title": "Find Duplicate File in System",
      "difficulty": "Medium",
      "constraints": [
        "1 <= paths.length <= 2 * 104",
        "1 <= paths[i].length <= 3000",
        "1 <= sum(paths[i].length) <= 5 * 105",
        "paths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.",
        "You may assume no files or directories share the same name in the same directory.",
        "You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info."
      ],
      "description": "Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.\nA group of duplicate files consists of at least two files that have the same content.\nA single directory info string in the input list has the following format:\nIt means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory \"root/d1/d2/.../dm\". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\nThe output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "find-pivot-index": {
      "questionId": "724",
      "title": "Find Pivot Index",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-1000 <= nums[i] <= 1000"
      ],
      "description": "Given an array of integers nums, calculate the pivot index of this array.\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\nReturn the leftmost pivot index. If no such index exists, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nNote: This question is the same as\u00a01991:\u00a0https://leetcode.com/problems/find-the-middle-index-in-array/"
    },
    "find-the-town-judge": {
      "questionId": "997",
      "title": "Find the Town Judge",
      "difficulty": "Easy",
      "constraints": [
        "1 <= n <= 1000",
        "0 <= trust.length <= 104",
        "trust[i].length == 2",
        "All the pairs of trust are unique.",
        "ai != bi",
        "1 <= ai, bi <= n"
      ],
      "description": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\nIf the town judge exists, then:\nYou are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "first-missing-positive": {
      "questionId": "41",
      "title": "First Missing Positive",
      "difficulty": "Hard",
      "constraints": [
        "1 <= nums.length <= 105",
        "-231 <= nums[i] <= 231 - 1"
      ],
      "description": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "first-unique-character-in-a-string": {
      "questionId": "387",
      "title": "First Unique Character in a String",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 105",
        "s consists of only lowercase English letters."
      ],
      "description": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "game-of-life": {
      "questionId": "289",
      "title": "Game of Life",
      "difficulty": "Medium",
      "constraints": [
        "m == board.length",
        "n == board[i].length",
        "1 <= m, n <= 25",
        "board[i][j] is 0 or 1."
      ],
      "description": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.\nGiven the current state of the board, update the board to reflect its next state.\nNote that you do not need to return anything.\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "group-anagrams": {
      "questionId": "49",
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "constraints": [
        "1 <= strs.length <= 104",
        "0 <= strs[i].length <= 100",
        "strs[i] consists of lowercase English letters."
      ],
      "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "groups-of-special-equivalent-strings": {
      "questionId": "893",
      "title": "Groups of Special-Equivalent Strings",
      "difficulty": "Medium",
      "constraints": [
        "1 <= words.length <= 1000",
        "1 <= words[i].length <= 20",
        "words[i] consist of lowercase English letters.",
        "All the strings are of the same length."
      ],
      "description": "You are given an array of strings of the same length words.\nIn one move, you can swap any two even indexed characters or any two odd indexed characters of a string words[i].\nTwo strings words[i] and words[j] are special-equivalent if after any number of moves, words[i] == words[j].\nA group of special-equivalent strings from words is a non-empty subset of words such that:\nReturn the number of groups of special-equivalent strings from words.\nExample 1:\nExample 2:\nConstraints:"
    },
    "h-index": {
      "questionId": "274",
      "title": "H-Index",
      "difficulty": "Medium",
      "constraints": [
        "n == citations.length",
        "1 <= n <= 5000",
        "0 <= citations[i] <= 1000"
      ],
      "description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\nExample 1:\nExample 2:\nConstraints:"
    },
    "image-overlap": {
      "questionId": "835",
      "title": "Image Overlap",
      "difficulty": "Medium",
      "constraints": [
        "n == img1.length == img1[i].length",
        "n == img2.length == img2[i].length",
        "1 <= n <= 30",
        "img1[i][j] is either 0 or 1.",
        "img2[i][j] is either 0 or 1."
      ],
      "description": "You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.\nWe translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.\nNote also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased.\nReturn the largest possible overlap.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "image-smoother": {
      "questionId": "661",
      "title": "Image Smoother",
      "difficulty": "Easy",
      "constraints": [
        "m == img.length",
        "n == img[i].length",
        "1 <= m, n <= 200",
        "0 <= img[i][j] <= 255"
      ],
      "description": "An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\nGiven an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.\nExample 1:\nExample 2:\nConstraints:"
    },
    "island-perimeter": {
      "questionId": "463",
      "title": "Island Perimeter",
      "difficulty": "Easy",
      "constraints": [
        "row == grid.length",
        "col == grid[i].length",
        "1 <= row, col <= 100",
        "grid[i][j] is 0 or 1.",
        "There is exactly one island in grid."
      ],
      "description": "You are given row x col grid representing a map where grid[i][j] = 1 represents\u00a0land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "isomorphic-strings": {
      "questionId": "205",
      "title": "Isomorphic Strings",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 5 * 104",
        "t.length == s.length",
        "s and t consist of any valid ascii character."
      ],
      "description": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "jewels-and-stones": {
      "questionId": "771",
      "title": "Jewels and Stones",
      "difficulty": "Easy",
      "constraints": [
        "1 <=\u00a0jewels.length, stones.length <= 50",
        "jewels and stones consist of only English letters.",
        "All the characters of\u00a0jewels are unique."
      ],
      "description": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\nExample 1:\nExample 2:\nConstraints:"
    },
    "keyboard-row": {
      "questionId": "500",
      "title": "Keyboard Row",
      "difficulty": "Easy",
      "constraints": [
        "1 <= words.length <= 20",
        "1 <= words[i].length <= 100",
        "words[i] consists of English letters (both lowercase and uppercase)."
      ],
      "description": "Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.\nNote that the strings are case-insensitive, both lowercased and uppercased of the same letter are treated as if they are at the same row.\nIn the American keyboard:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "largest-number-at-least-twice-of-others": {
      "questionId": "747",
      "title": "Largest Number At Least Twice of Others",
      "difficulty": "Easy",
      "constraints": [
        "2 <= nums.length <= 50",
        "0 <= nums[i] <= 100",
        "The largest element in nums is unique."
      ],
      "description": "You are given an integer array nums where the largest integer is unique.\nDetermine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-common-prefix": {
      "questionId": "14",
      "title": "Longest Common Prefix",
      "difficulty": "Easy",
      "constraints": [
        "1 <= strs.length <= 200",
        "0 <= strs[i].length <= 200",
        "strs[i] consists of only lowercase English letters if it is non-empty."
      ],
      "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-consecutive-sequence": {
      "questionId": "128",
      "title": "Longest Consecutive Sequence",
      "difficulty": "Medium",
      "constraints": [
        "0 <= nums.length <= 105",
        "-109 <= nums[i] <= 109"
      ],
      "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "longest-continuous-increasing-subsequence": {
      "questionId": "674",
      "title": "Longest Continuous Increasing Subsequence",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-109 <= nums[i] <= 109"
      ],
      "description": "Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.\nA continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].\nExample 1:\nExample 2:\nConstraints:"
    },
    "majority-element": {
      "questionId": "169",
      "title": "Majority Element",
      "difficulty": "Easy",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 5 * 104",
        "-109 <= nums[i] <= 109"
      ],
      "description": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.\nExample 1:\nExample 2:\nConstraints:"
    },
    "majority-element-ii": {
      "questionId": "229",
      "title": "Majority Element II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 5 * 104",
        "-109 <= nums[i] <= 109"
      ],
      "description": "Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve the problem in linear time and in O(1) space?"
    },
    "max-consecutive-ones": {
      "questionId": "485",
      "title": "Max Consecutive Ones",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 105",
        "nums[i] is either 0 or 1."
      ],
      "description": "Given a binary array nums, return the maximum number of consecutive 1's in the array.\nExample 1:\nExample 2:\nConstraints:"
    },
    "maximize-distance-to-closest-person": {
      "questionId": "849",
      "title": "Maximize Distance to Closest Person",
      "difficulty": "Medium",
      "constraints": [
        "2 <= seats.length <= 2 * 104",
        "seats[i]\u00a0is 0 or\u00a01.",
        "At least one seat is empty.",
        "At least one seat is occupied."
      ],
      "description": "You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed).\nThere is at least one empty seat, and at least one person sitting.\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\nReturn that maximum distance to the closest person.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "maximum-gap": {
      "questionId": "164",
      "title": "Maximum Gap",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 109"
      ],
      "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.\nExample 1:\nExample 2:\nConstraints:"
    },
    "min-cost-to-connect-all-points": {
      "questionId": "1584",
      "title": "Min Cost to Connect All Points",
      "difficulty": "Medium",
      "constraints": [
        "1 <= points.length <= 1000",
        "-106 <= xi, yi <= 106",
        "All pairs (xi, yi) are distinct."
      ],
      "description": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minesweeper": {
      "questionId": "529",
      "title": "Minesweeper",
      "difficulty": "Medium",
      "constraints": [
        "m == board.length",
        "n == board[i].length",
        "1 <= m, n <= 50",
        "board[i][j] is either 'M', 'E', 'B', or a digit from '1' to '8'.",
        "click.length == 2",
        "0 <= clickr < m",
        "0 <= clickc < n",
        "board[clickr][clickc] is either 'M' or 'E'."
      ],
      "description": "Let's play the minesweeper game (Wikipedia, online game)!\nYou are given an m x n char matrix board representing the game board where:\nYou are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E').\nReturn the board after revealing this position according to the following rules:\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-index-sum-of-two-lists": {
      "questionId": "599",
      "title": "Minimum Index Sum of Two Lists",
      "difficulty": "Easy",
      "constraints": [
        "1 <= list1.length, list2.length <= 1000",
        "1 <= list1[i].length, list2[i].length <= 30",
        "list1[i] and list2[i] consist of spaces ' ' and English letters.",
        "All the strings of list1 are unique.",
        "All the strings of list2 are unique.",
        "There is at least a common string between list1 and list2."
      ],
      "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "monotonic-array": {
      "questionId": "896",
      "title": "Monotonic Array",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 105",
        "-105 <= nums[i] <= 105"
      ],
      "description": "An array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].\nGiven an integer array nums, return true if the given array is monotonic, or false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "most-common-word": {
      "questionId": "819",
      "title": "Most Common Word",
      "difficulty": "Easy",
      "constraints": [
        "1 <= paragraph.length <= 1000",
        "paragraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".",
        "0 <= banned.length <= 100",
        "1 <= banned[i].length <= 10",
        "banned[i] consists of only lowercase English letters."
      ],
      "description": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\nNote that words can not contain punctuation symbols.\nExample 1:\nExample 2:\nConstraints:"
    },
    "most-stones-removed-with-same-row-or-column": {
      "questionId": "947",
      "title": "Most Stones Removed with Same Row or Column",
      "difficulty": "Medium",
      "constraints": [
        "1 <= stones.length <= 1000",
        "0 <= xi, yi <= 104",
        "No two stones are at the same coordinate point."
      ],
      "description": "On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\nA stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\nGiven an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "n-repeated-element-in-size-2n-array": {
      "questionId": "961",
      "title": "N-Repeated Element in Size 2N Array",
      "difficulty": "Easy",
      "constraints": [
        "2 <= n <= 5000",
        "nums.length == 2 * n",
        "0 <= nums[i] <= 104",
        "nums contains n + 1 unique elements and one of them is repeated exactly n times."
      ],
      "description": "You are given an integer array nums with the following properties:\nReturn the element that is repeated n times.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "non-decreasing-array": {
      "questionId": "665",
      "title": "Non-decreasing Array",
      "difficulty": "Medium",
      "constraints": [
        "n == nums.length",
        "1 <= n <= 104",
        "-105 <= nums[i] <= 105"
      ],
      "description": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\nWe define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).\nExample 1:\nExample 2:\nConstraints:"
    },
    "number-of-enclaves": {
      "questionId": "1020",
      "title": "Number of Enclaves",
      "difficulty": "Medium",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 500",
        "grid[i][j] is either 0 or 1."
      ],
      "description": "You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.\nA move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.\nReturn the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.\nExample 1:\nExample 2:\nConstraints:"
    },
    "number-of-lines-to-write-string": {
      "questionId": "806",
      "title": "Number of Lines To Write String",
      "difficulty": "Easy",
      "constraints": [
        "widths.length == 26",
        "2 <= widths[i] <= 10",
        "1 <= s.length <= 1000",
        "s contains only lowercase English letters."
      ],
      "description": "You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of 'a', widths[1] is the width of 'b', and so on.\nYou are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s.\nReturn an array result of length 2 where:\nExample 1:\nExample 2:\nConstraints:"
    },
    "open-the-lock": {
      "questionId": "752",
      "title": "Open the Lock",
      "difficulty": "Medium",
      "constraints": [
        "1 <= deadends.length <= 500",
        "deadends[i].length == 4",
        "target.length == 4",
        "target will not be in the list deadends.",
        "target and deadends[i] consist of digits only."
      ],
      "description": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "pairs-of-songs-with-total-durations-divisible-by-60": {
      "questionId": "1010",
      "title": "Pairs of Songs With Total Durations Divisible by 60",
      "difficulty": "Medium",
      "constraints": [
        "1 <= time.length <= 6 * 104",
        "1 <= time[i] <= 500"
      ],
      "description": "You are given a list of songs where the ith song has a duration of time[i] seconds.\nReturn the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.\nExample 1:\nExample 2:\nConstraints:"
    },
    "partition-array-into-disjoint-intervals": {
      "questionId": "915",
      "title": "Partition Array into Disjoint Intervals",
      "difficulty": "Medium",
      "constraints": [
        "2 <= nums.length <= 105",
        "0 <= nums[i] <= 106",
        "There is at least one valid answer for the given input."
      ],
      "description": "Given an integer array nums, partition it into two (contiguous) subarrays left and right so that:\nReturn the length of left after such a partitioning.\nTest cases are generated such that partitioning exists.\nExample 1:\nExample 2:\nConstraints:"
    },
    "peeking-iterator": {
      "questionId": "284",
      "title": "Peeking Iterator",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 1000",
        "1 <= nums[i] <= 1000",
        "All the calls to next and peek are valid.",
        "At most 1000 calls will be made to next, hasNext, and peek."
      ],
      "description": "Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.\nImplement the PeekingIterator class:\nNote: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.\nExample 1:\nConstraints:"
    },
    "product-of-array-except-self": {
      "questionId": "238",
      "title": "Product of Array Except Self",
      "difficulty": "Medium",
      "constraints": [
        "2 <= nums.length <= 105",
        "-30 <= nums[i] <= 30",
        "The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer."
      ],
      "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.\nExample 1:\nExample 2:\nConstraints:\nFollow up:\u00a0Can you solve the problem in O(1)\u00a0extra\u00a0space complexity? (The output array does not count as extra space for space complexity analysis.)"
    },
    "queue-reconstruction-by-height": {
      "questionId": "406",
      "title": "Queue Reconstruction by Height",
      "difficulty": "Medium",
      "constraints": [
        "1 <= people.length <= 2000",
        "0 <= hi <= 106",
        "0 <= ki < people.length",
        "It is guaranteed that the queue can be reconstructed."
      ],
      "description": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\nExample 1:\nExample 2:\nConstraints:"
    },
    "range-sum-query-mutable": {
      "questionId": "307",
      "title": "Range Sum Query - Mutable",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 3 * 104",
        "-100 <= nums[i] <= 100",
        "0 <= index < nums.length",
        "-100 <= val <= 100",
        "0 <= left <= right < nums.length",
        "At most 3 * 104 calls will be made to update and sumRange."
      ],
      "description": "Given an integer array nums, handle multiple queries of the following types:\nImplement the NumArray class:\nExample 1:\nConstraints:"
    },
    "ransom-note": {
      "questionId": "383",
      "title": "Ransom Note",
      "difficulty": "Easy",
      "constraints": [
        "1 <= ransomNote.length, magazine.length <= 105",
        "ransomNote and magazine consist of lowercase English letters."
      ],
      "description": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "regions-cut-by-slashes": {
      "questionId": "959",
      "title": "Regions Cut By Slashes",
      "difficulty": "Medium",
      "constraints": [
        "n == grid.length == grid[i].length",
        "1 <= n <= 30",
        "grid[i][j] is either '/', '\\', or ' '."
      ],
      "description": "An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\\', or blank space ' '. These characters divide the square into contiguous regions.\nGiven the grid grid represented as a string array, return the number of regions.\nNote that backslash characters are escaped, so a '\\' is represented as '\\\\'.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "remove-comments": {
      "questionId": "722",
      "title": "Remove Comments",
      "difficulty": "Medium",
      "constraints": [
        "1 <= source.length <= 100",
        "0 <= source[i].length <= 80",
        "source[i] consists of printable ASCII characters.",
        "Every open block comment is eventually closed.",
        "There are no single-quote or\u00a0double-quote in the input."
      ],
      "description": "Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. This represents the result of splitting the original source code string by the newline character '\\n'.\nIn C++, there are two types of comments, line comments, and block comments.\nThe first effective comment takes precedence over others.\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\nThere will be no control characters, single quote, or double quote characters.\nAlso, nothing else such as defines or macros will interfere with the comments.\nIt is guaranteed that every open block comment will eventually be closed, so \"/*\" outside of a line or block comment always starts a new comment.\nFinally, implicit newline characters can be deleted by block comments. Please see the examples below for details.\nAfter removing the comments from the source code, return the source code in the same format.\nExample 1:\nExample 2:\nConstraints:"
    },
    "reshape-the-matrix": {
      "questionId": "566",
      "title": "Reshape the Matrix",
      "difficulty": "Easy",
      "constraints": [
        "m == mat.length",
        "n == mat[i].length",
        "1 <= m, n <= 100",
        "-1000 <= mat[i][j] <= 1000",
        "1 <= r, c <= 300"
      ],
      "description": "In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.\nYou are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\nExample 1:\nExample 2:\nConstraints:"
    },
    "reveal-cards-in-increasing-order": {
      "questionId": "950",
      "title": "Reveal Cards In Increasing Order",
      "difficulty": "Medium",
      "constraints": [
        "1 <= deck.length <= 1000",
        "1 <= deck[i] <= 106",
        "All the values of deck are unique."
      ],
      "description": "You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\nYou will do the following steps repeatedly until all cards are revealed:\nReturn an ordering of the deck that would reveal the cards in increasing order.\nNote that the first entry in the answer is considered to be the top of the deck.\nExample 1:\nExample 2:\nConstraints:"
    },
    "rle-iterator": {
      "questionId": "900",
      "title": "RLE Iterator",
      "difficulty": "Medium",
      "constraints": [
        "2 <= encoding.length <= 1000",
        "encoding.length is even.",
        "0 <= encoding[i] <= 109",
        "1 <= n <= 109",
        "At most 1000 calls will be made to next."
      ],
      "description": "We can use run-length encoding (i.e., RLE) to encode a sequence of integers. In a run-length encoded array of even length encoding (0-indexed), for all even i, encoding[i] tells us the number of times that the non-negative integer value encoding[i + 1] is repeated in the sequence.\nGiven a run-length encoded array, design an iterator that iterates through it.\nImplement the RLEIterator class:\nExample 1:\nConstraints:"
    },
    "rotate-image": {
      "questionId": "48",
      "title": "Rotate Image",
      "difficulty": "Medium",
      "constraints": [
        "n == matrix.length == matrix[i].length",
        "1 <= n <= 20",
        "-1000 <= matrix[i][j] <= 1000"
      ],
      "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nExample 2:\nConstraints:"
    },
    "satisfiability-of-equality-equations": {
      "questionId": "990",
      "title": "Satisfiability of Equality Equations",
      "difficulty": "Medium",
      "constraints": [
        "1 <= equations.length <= 500",
        "equations[i].length == 4",
        "equations[i][0] is a lowercase letter.",
        "equations[i][1] is either '=' or '!'.",
        "equations[i][2] is '='.",
        "equations[i][3] is a lowercase letter."
      ],
      "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "set-matrix-zeroes": {
      "questionId": "73",
      "title": "Set Matrix Zeroes",
      "difficulty": "Medium",
      "constraints": [
        "m == matrix.length",
        "n == matrix[0].length",
        "1 <= m, n <= 200",
        "-231 <= matrix[i][j] <= 231 - 1"
      ],
      "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "shifting-letters": {
      "questionId": "848",
      "title": "Shifting Letters",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 105",
        "s consists of lowercase English letters.",
        "shifts.length == s.length",
        "0 <= shifts[i] <= 109"
      ],
      "description": "You are given a string s of lowercase English letters and an integer array shifts of the same length.\nCall the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').\nNow for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.\nReturn the final string after all such shifts to s are applied.\nExample 1:\nExample 2:\nConstraints:"
    },
    "shortest-bridge": {
      "questionId": "934",
      "title": "Shortest Bridge",
      "difficulty": "Medium",
      "constraints": [
        "n == grid.length == grid[i].length",
        "2 <= n <= 100",
        "grid[i][j] is either 0 or 1.",
        "There are exactly two islands in grid."
      ],
      "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "shortest-completing-word": {
      "questionId": "748",
      "title": "Shortest Completing Word",
      "difficulty": "Easy",
      "constraints": [
        "1 <= licensePlate.length <= 7",
        "licensePlate contains digits, letters (uppercase or lowercase), or space ' '.",
        "1 <= words.length <= 1000",
        "1 <= words[i].length <= 15",
        "words[i] consists of lower case English letters."
      ],
      "description": "Given a string licensePlate and an array of strings words, find the shortest completing word in words.\nA completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more.\nFor example, if licensePlate = \"aBc 12c\", then it contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible completing words are \"abccdef\", \"caaacab\", and \"cbca\".\nReturn the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words.\nExample 1:\nExample 2:\nConstraints:"
    },
    "spiral-matrix": {
      "questionId": "54",
      "title": "Spiral Matrix",
      "difficulty": "Medium",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 10",
        "-100 <= matrix[i][j] <= 100"
      ],
      "description": "Given an m x n matrix, return all elements of the matrix in spiral order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "spiral-matrix-ii": {
      "questionId": "59",
      "title": "Spiral Matrix II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= n <= 20"
      ],
      "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "spiral-matrix-iii": {
      "questionId": "885",
      "title": "Spiral Matrix III",
      "difficulty": "Medium",
      "constraints": [
        "1 <= rows, cols <= 100",
        "0 <= rStart < rows",
        "0 <= cStart < cols"
      ],
      "description": "You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.\nReturn an array of coordinates representing the positions of the grid in the order you visited them.\nExample 1:\nExample 2:\nConstraints:"
    },
    "subarray-sum-equals-k": {
      "questionId": "560",
      "title": "Subarray Sum Equals K",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 2 * 104",
        "-1000 <= nums[i] <= 1000",
        "-107 <= k <= 107"
      ],
      "description": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nExample 2:\nConstraints:"
    },
    "subarray-sums-divisible-by-k": {
      "questionId": "974",
      "title": "Subarray Sums Divisible by K",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 3 * 104",
        "-104 <= nums[i] <= 104",
        "2 <= k <= 104"
      ],
      "description": "Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\nA subarray is a contiguous part of an array.\nExample 1:\nExample 2:\nConstraints:"
    },
    "subdomain-visit-count": {
      "questionId": "811",
      "title": "Subdomain Visit Count",
      "difficulty": "Medium",
      "constraints": [
        "1 <= cpdomain.length <= 100",
        "1 <= cpdomain[i].length <= 100",
        "cpdomain[i] follows either the \"repi d1i.d2i.d3i\" format or the \"repi d1i.d2i\" format.",
        "repi is an integer in the range [1, 104].",
        "d1i, d2i, and d3i consist of lowercase English letters."
      ],
      "description": "A website domain \"discuss.leetcode.com\" consists of various subdomains. At the top level, we have \"com\", at the next level, we have \"leetcode.com\"\u00a0and at the lowest level, \"discuss.leetcode.com\". When we visit a domain like \"discuss.leetcode.com\", we will also visit the parent domains \"leetcode.com\" and \"com\" implicitly.\nA count-paired domain is a domain that has one of the two formats \"rep d1.d2.d3\" or \"rep d1.d2\" where rep is the number of visits to the domain and d1.d2.d3 is the domain itself.\nGiven an array of count-paired domains cpdomains, return an array of the count-paired domains of each subdomain in the input. You may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "sum-of-even-numbers-after-queries": {
      "questionId": "985",
      "title": "Sum of Even Numbers After Queries",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 104",
        "-104 <= nums[i] <= 104",
        "1 <= queries.length <= 104",
        "-104 <= vali <= 104",
        "0 <= indexi < nums.length"
      ],
      "description": "You are given an integer array nums and an array queries where queries[i] = [vali, indexi].\nFor each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums.\nReturn an integer array answer where answer[i] is the answer to the ith query.\nExample 1:\nExample 2:\nConstraints:"
    },
    "summary-ranges": {
      "questionId": "228",
      "title": "Summary Ranges",
      "difficulty": "Easy",
      "constraints": [
        "0 <= nums.length <= 20",
        "-231 <= nums[i] <= 231 - 1",
        "All the values of nums are unique.",
        "nums is sorted in ascending order."
      ],
      "description": "You are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:\nExample 1:\nExample 2:\nConstraints:"
    },
    "teemo-attacking": {
      "questionId": "495",
      "title": "Teemo Attacking",
      "difficulty": "Easy",
      "constraints": [
        "1 <= timeSeries.length <= 104",
        "0 <= timeSeries[i], duration <= 107",
        "timeSeries is sorted in non-decreasing order."
      ],
      "description": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.\nYou are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.\nReturn the total number of seconds that Ashe is poisoned.\nExample 1:\nExample 2:\nConstraints:"
    },
    "third-maximum-number": {
      "questionId": "414",
      "title": "Third Maximum Number",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-231 <= nums[i] <= 231 - 1"
      ],
      "description": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "toeplitz-matrix": {
      "questionId": "766",
      "title": "Toeplitz Matrix",
      "difficulty": "Easy",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 20",
        "0 <= matrix[i][j] <= 99"
      ],
      "description": "Given an m x n matrix, return\u00a0true\u00a0if the matrix is Toeplitz. Otherwise, return false.\nA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.\nExample 1:\nExample 2:\nConstraints:\nFollow up:"
    },
    "transpose-matrix": {
      "questionId": "867",
      "title": "Transpose Matrix",
      "difficulty": "Easy",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 1000",
        "1 <= m * n <= 105",
        "-109 <= matrix[i][j] <= 109"
      ],
      "description": "Given a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.\nExample 1:\nExample 2:\nConstraints:"
    },
    "two-sum": {
      "questionId": "1",
      "title": "Two Sum",
      "difficulty": "Easy",
      "constraints": [
        "2 <= nums.length <= 104",
        "-109 <= nums[i] <= 109",
        "-109 <= target <= 109",
        "Only one valid answer exists."
      ],
      "description": "Given an array of integers nums\u00a0and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "uncommon-words-from-two-sentences": {
      "questionId": "884",
      "title": "Uncommon Words from Two Sentences",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s1.length, s2.length <= 200",
        "s1 and s2 consist of lowercase English letters and spaces.",
        "s1 and s2 do not have leading or trailing spaces.",
        "All the words in s1 and s2 are separated by a single space."
      ],
      "description": "A sentence is a string of single-space separated words where each word consists only of lowercase letters.\nA word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\nGiven two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:"
    },
    "unique-morse-code-words": {
      "questionId": "804",
      "title": "Unique Morse Code Words",
      "difficulty": "Easy",
      "constraints": [
        "1 <= words.length <= 100",
        "1 <= words[i].length <= 12",
        "words[i] consists of lowercase English letters."
      ],
      "description": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter.\nReturn the number of different transformations among all words we have.\nExample 1:\nExample 2:\nConstraints:"
    },
    "valid-anagram": {
      "questionId": "242",
      "title": "Valid Anagram",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length, t.length <= 5 * 104",
        "s and t consist of lowercase English letters."
      ],
      "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nExample 1:\nExample 2:\nConstraints:\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?"
    },
    "valid-mountain-array": {
      "questionId": "941",
      "title": "Valid Mountain Array",
      "difficulty": "Easy",
      "constraints": [
        "1 <= arr.length <= 104",
        "0 <= arr[i] <= 104"
      ],
      "description": "Given an array of integers arr, return true if and only if it is a valid mountain array.\nRecall that arr is a mountain array if and only if:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "valid-sudoku": {
      "questionId": "36",
      "title": "Valid Sudoku",
      "difficulty": "Medium",
      "constraints": [
        "board.length == 9",
        "board[i].length == 9",
        "board[i][j] is a digit 1-9 or '.'."
      ],
      "description": "Determine if a\u00a09 x 9 Sudoku board\u00a0is valid.\u00a0Only the filled cells need to be validated\u00a0according to the following rules:\nNote:\nExample 1:\nExample 2:\nConstraints:"
    },
    "valid-tic-tac-toe-state": {
      "questionId": "794",
      "title": "Valid Tic-Tac-Toe State",
      "difficulty": "Medium",
      "constraints": [
        "board.length == 3",
        "board[i].length == 3",
        "board[i][j] is either 'X', 'O', or ' '."
      ],
      "description": "Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\nThe board is a 3 x 3 array that consists of characters ' ', 'X', and 'O'. The ' ' character represents an empty square.\nHere are the rules of Tic-Tac-Toe:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "verifying-an-alien-dictionary": {
      "questionId": "953",
      "title": "Verifying an Alien Dictionary",
      "difficulty": "Easy",
      "constraints": [
        "1 <= words.length <= 100",
        "1 <= words[i].length <= 20",
        "order.length == 26",
        "All characters in words[i] and order are English lowercase letters."
      ],
      "description": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "vowel-spellchecker": {
      "questionId": "966",
      "title": "Vowel Spellchecker",
      "difficulty": "Medium",
      "constraints": [
        "1 <= wordlist.length, queries.length <= 5000",
        "1 <= wordlist[i].length, queries[i].length <= 7",
        "wordlist[i] and queries[i] consist only of only English letters."
      ],
      "description": "Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.\nFor a given query word, the spell checker handles two categories of spelling mistakes:\nIn addition, the spell checker operates under the following precedence rules:\nGiven some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].\nExample 1:\nExample 2:\nConstraints:"
    },
    "walking-robot-simulation": {
      "questionId": "874",
      "title": "Walking Robot Simulation",
      "difficulty": "Medium",
      "constraints": [
        "1 <= commands.length <= 104",
        "commands[i] is either -2, -1, or an integer in the range [1, 9].",
        "0 <= obstacles.length <= 104",
        "-3 * 104 <= xi, yi <= 3 * 104",
        "The answer is guaranteed to be less than 231."
      ],
      "description": "A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot receives an array of integers commands, which represents a sequence of moves that it needs to execute. There are only three possible types of instructions the robot can receive:\nSome of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, it will stay in its current location (on the block adjacent to the obstacle) and move onto the next command.\nReturn the maximum squared Euclidean distance that the robot reaches at any point in its path (i.e. if the distance is 5, return 25).\nNote:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "word-pattern": {
      "questionId": "290",
      "title": "Word Pattern",
      "difficulty": "Easy",
      "constraints": [
        "1 <= pattern.length <= 300",
        "pattern contains only lower-case English letters.",
        "1 <= s.length <= 3000",
        "s contains only lowercase English letters and spaces ' '.",
        "s does not contain any leading or trailing spaces.",
        "All the words in s are separated by a single space."
      ],
      "description": "Given a pattern and a string s, find if s\u00a0follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "word-subsets": {
      "questionId": "916",
      "title": "Word Subsets",
      "difficulty": "Medium",
      "constraints": [
        "1 <= words1.length, words2.length <= 104",
        "1 <= words1[i].length, words2[i].length <= 10",
        "words1[i] and words2[i] consist only of lowercase English letters.",
        "All the strings of words1 are unique."
      ],
      "description": "You are given two string arrays words1 and words2.\nA string b is a subset of string a if every letter in b occurs in a including multiplicity.\nA string a from words1 is universal if for every string b in words2, b is a subset of a.\nReturn an array of all the universal strings in words1. You may return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "unique-email-addresses": {
      "questionId": "929",
      "title": "Unique Email Addresses",
      "difficulty": "Easy",
      "constraints": [
        "1 <= emails.length <= 100",
        "1 <= emails[i].length <= 100",
        "emails[i] consist of lowercase English letters, '+', '.' and '@'.",
        "Each emails[i] contains exactly one '@' character.",
        "All local and domain names are non-empty.",
        "Local names do not start with a '+' character.",
        "Domain names end with the \".com\" suffix.",
        "Domain names must contain at least one character before \".com\" suffix."
      ],
      "description": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\nIf you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\nIf you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\nIt is possible to use both of these rules at the same time.\nGiven an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.\nExample 1:\nExample 2:\nConstraints:"
    },
    "reorder-data-in-log-files": {
      "questionId": "937",
      "title": "Reorder Data in Log Files",
      "difficulty": "Medium",
      "constraints": [
        "1 <= logs.length <= 100",
        "3 <= logs[i].length <= 100",
        "All the tokens of logs[i] are separated by a single space.",
        "logs[i] is guaranteed to have an identifier and at least one word after the identifier."
      ],
      "description": "You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.\nThere are two types of logs:\nReorder these logs so that:\nReturn the final order of the logs.\nExample 1:\nExample 2:\nConstraints:"
    }
  }
}