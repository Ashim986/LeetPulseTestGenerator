{
  "topic": "greedy",
  "problems": {
    "array-of-doubled-pairs": {
      "questionId": "954",
      "title": "Array of Doubled Pairs",
      "difficulty": "Medium",
      "constraints": [
        "2 <= arr.length <= 3 * 104",
        "arr.length is even.",
        "-105 <= arr[i] <= 105"
      ],
      "description": "Given an integer array of even length arr, return true if it is possible to reorder arr such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 <= i < len(arr) / 2, or false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "array-partition": {
      "questionId": "561",
      "title": "Array Partition",
      "difficulty": "Easy",
      "constraints": [
        "1 <= n <= 104",
        "nums.length == 2 * n",
        "-104 <= nums[i] <= 104"
      ],
      "description": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.\nExample 1:\nExample 2:\nConstraints:"
    },
    "can-place-flowers": {
      "questionId": "605",
      "title": "Can Place Flowers",
      "difficulty": "Easy",
      "constraints": [
        "1 <= flowerbed.length <= 2 * 104",
        "flowerbed[i] is 0 or 1.",
        "There are no two adjacent flowers in flowerbed.",
        "0 <= n <= flowerbed.length"
      ],
      "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "delete-columns-to-make-sorted-ii": {
      "questionId": "955",
      "title": "Delete Columns to Make Sorted II",
      "difficulty": "Medium",
      "constraints": [
        "n == strs.length",
        "1 <= n <= 100",
        "1 <= strs[i].length <= 100",
        "strs[i] consists of lowercase English letters."
      ],
      "description": "You are given an array of n strings strs, all of the same length.\nWe may choose any deletion indices, and we delete all the characters in those indices for each string.\nFor example, if we have strs = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"].\nSuppose we chose a set of deletion indices answer such that after deletions, the final array has its elements in lexicographic order (i.e., strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]). Return the minimum possible value of answer.length.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "dota2-senate": {
      "questionId": "649",
      "title": "Dota2 Senate",
      "difficulty": "Medium",
      "constraints": [
        "n == senate.length",
        "1 <= n <= 104",
        "senate[i] is either 'R' or 'D'."
      ],
      "description": "In the world of Dota2, there are two parties: the Radiant and the Dire.\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\nGiven a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\".\nExample 1:\nExample 2:\nConstraints:"
    },
    "gas-station": {
      "questionId": "134",
      "title": "Gas Station",
      "difficulty": "Medium",
      "constraints": [
        "n == gas.length == cost.length",
        "1 <= n <= 105",
        "0 <= gas[i], cost[i] <= 104",
        "The input is generated such that the answer is unique."
      ],
      "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.\nExample 1:\nExample 2:\nConstraints:"
    },
    "hand-of-straights": {
      "questionId": "846",
      "title": "Hand of Straights",
      "difficulty": "Medium",
      "constraints": [
        "1 <= hand.length <= 104",
        "0 <= hand[i] <= 109",
        "1 <= groupSize <= hand.length"
      ],
      "description": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.\nExample 1:\nExample 2:\nConstraints:\nNote: This question is the same as 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/"
    },
    "increasing-triplet-subsequence": {
      "questionId": "334",
      "title": "Increasing Triplet Subsequence",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 5 * 105",
        "-231 <= nums[i] <= 231 - 1"
      ],
      "description": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "largest-number": {
      "questionId": "179",
      "title": "Largest Number",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 100",
        "0 <= nums[i] <= 109"
      ],
      "description": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\nSince the result may be very large, so you need to return a string instead of an integer.\nExample 1:\nExample 2:\nConstraints:"
    },
    "lemonade-change": {
      "questionId": "860",
      "title": "Lemonade Change",
      "difficulty": "Easy",
      "constraints": [
        "1 <= bills.length <= 105",
        "bills[i] is either 5, 10, or 20."
      ],
      "description": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.\nNote that you do not have any change in hand at first.\nGiven an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.\nExample 1:\nExample 2:\nConstraints:"
    },
    "longest-palindrome": {
      "questionId": "409",
      "title": "Longest Palindrome",
      "difficulty": "Easy",
      "constraints": [
        "1 <= s.length <= 2000",
        "s consists of lowercase and/or uppercase English\u00a0letters only."
      ],
      "description": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome\u00a0that can be built with those letters.\nLetters are case sensitive, for example, \"Aa\" is not considered a palindrome.\nExample 1:\nExample 2:\nConstraints:"
    },
    "max-increase-to-keep-city-skyline": {
      "questionId": "807",
      "title": "Max Increase to Keep City Skyline",
      "difficulty": "Medium",
      "constraints": [
        "n == grid.length",
        "n == grid[r].length",
        "2 <= n <= 50",
        "0 <= grid[r][c] <= 100"
      ],
      "description": "There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.\nA city's skyline is the\u00a0outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different.\nWe are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.\nReturn the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\nExample 1:\nExample 2:\nConstraints:"
    },
    "maximize-sum-of-array-after-k-negations": {
      "questionId": "1005",
      "title": "Maximize Sum Of Array After K Negations",
      "difficulty": "Easy",
      "constraints": [
        "1 <= nums.length <= 104",
        "-100 <= nums[i] <= 100",
        "1 <= k <= 104"
      ],
      "description": "Given an integer array nums and an integer k, modify the array in the following way:\nYou should apply this process exactly k times. You may choose the same index i multiple times.\nReturn the largest possible sum of the array after modifying it in this way.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "maximum-distance-in-arrays": {
      "questionId": "624",
      "title": "Maximum Distance in Arrays",
      "difficulty": "Medium",
      "constraints": [
        "m == arrays.length",
        "2 <= m <= 105",
        "1 <= arrays[i].length <= 500",
        "-104 <= arrays[i][j] <= 104",
        "arrays[i] is sorted in ascending order.",
        "There will be at most 105 integers in all the arrays."
      ],
      "description": "You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|.\nReturn the maximum distance.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-domino-rotations-for-equal-row": {
      "questionId": "1007",
      "title": "Minimum Domino Rotations For Equal Row",
      "difficulty": "Medium",
      "constraints": [
        "2 <= tops.length <= 2 * 104",
        "bottoms.length == tops.length",
        "1 <= tops[i], bottoms[i] <= 6"
      ],
      "description": "In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\nWe may rotate the ith domino, so that tops[i] and bottoms[i] swap values.\nReturn the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.\nIf it cannot be done, return -1.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-increment-to-make-array-unique": {
      "questionId": "945",
      "title": "Minimum Increment to Make Array Unique",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 105"
      ],
      "description": "You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.\nReturn the minimum number of moves to make every value in nums unique.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nExample 2:\nConstraints:"
    },
    "minimum-number-of-arrows-to-burst-balloons": {
      "questionId": "452",
      "title": "Minimum Number of Arrows to Burst Balloons",
      "difficulty": "Medium",
      "constraints": [
        "1 <= points.length <= 105",
        "points[i].length == 2",
        "-231 <= xstart < xend <= 231 - 1"
      ],
      "description": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "partition-array-into-three-parts-with-equal-sum": {
      "questionId": "1013",
      "title": "Partition Array Into Three Parts With Equal Sum",
      "difficulty": "Easy",
      "constraints": [
        "3 <= arr.length <= 5 * 104",
        "-104 <= arr[i] <= 104"
      ],
      "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "partition-labels": {
      "questionId": "763",
      "title": "Partition Labels",
      "difficulty": "Medium",
      "constraints": [
        "1 <= s.length <= 500",
        "s consists of lowercase English letters."
      ],
      "description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string \"ababcc\" can be partitioned into [\"abab\", \"cc\"], but partitions such as [\"aba\", \"bcc\"] or [\"ab\", \"ab\", \"cc\"] are invalid.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.\nExample 1:\nExample 2:\nConstraints:"
    },
    "score-after-flipping-matrix": {
      "questionId": "861",
      "title": "Score After Flipping Matrix",
      "difficulty": "Medium",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 20",
        "grid[i][j] is either 0 or 1."
      ],
      "description": "You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).\nExample 1:\nExample 2:\nConstraints:"
    },
    "split-array-into-consecutive-subsequences": {
      "questionId": "659",
      "title": "Split Array into Consecutive Subsequences",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 104",
        "-1000 <= nums[i] <= 1000",
        "nums is sorted in non-decreasing order."
      ],
      "description": "You are given an integer array nums that is sorted in non-decreasing order.\nDetermine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:\nReturn true if you can split nums according to the above conditions, or false otherwise.\nA subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).\nExample 1:\nExample 2:\nExample 3:\nConstraints:"
    },
    "string-without-aaa-or-bbb": {
      "questionId": "984",
      "title": "String Without AAA or BBB",
      "difficulty": "Medium",
      "constraints": [
        "0 <= a, b <= 100",
        "It is guaranteed such an s exists for the given a and b."
      ],
      "description": "Given two integers a and b, return any string s such that:\nExample 1:\nExample 2:\nConstraints:"
    },
    "wiggle-sort-ii": {
      "questionId": "324",
      "title": "Wiggle Sort II",
      "difficulty": "Medium",
      "constraints": [
        "1 <= nums.length <= 5 * 104",
        "0 <= nums[i] <= 5000",
        "It is guaranteed that there will be an answer for the given input nums."
      ],
      "description": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\nYou may assume the input array always has a valid answer.\nExample 1:\nExample 2:\nConstraints:"
    }
  }
}